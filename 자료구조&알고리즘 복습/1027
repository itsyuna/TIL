
[ê°œì¸ë³µìŠµ ë° ì¶”ê°€í•™ìŠµ]     + â­ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ê¸°

        
        ğŸ“‚ ì•Œê³ ë¦¬ì¦˜
        
              #ï¸âƒ£ Dijkstra ì•Œê³ ë¦¬ì¦˜
              
                    : ê·¸ë˜í”„ì—ì„œ â­ì¶œë°œì ê³¼ ë„ì°©ì  ì‚¬ì´ì˜ ìµœë‹¨ ê±°ë¦¬â­ë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
                    
                    â­ ë³´í†µ ë‹¨ì¼ ì •ì  ê°„ ìµœë˜ ê²½ë¡œ ì‚°ì¶œì‹œ ì‚¬ìš©, ë„ë¡œ êµí†µë§ì´ë‚˜ OSPFë“±ì˜ ë„¤íŠ¸ì›Œí¬ ë¼ìš°íŒ… í”„ë¡œí† ì½œì— ë„ë¦¬ ì´ìš©
                    
                    ğŸ”» êµ¬í˜„ ë©”ì„œë“œ(method)
                        
                          â—½ ì •ì /ê°„ì„  ì¶”ê°€: ShortestPath.addVertex() / ShortestPath.addEdge()
                          
                          â—½ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ : ShortestPath._extractMin() / ShortestPath.dijkstra()
                
                
              #ï¸âƒ£ Dijkstra ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ (1)
              
                    // ShortestPath() : edge object ê°ì²´ ì €ì¥ì„ ìœ„í•œ ìƒì„±ì
                    // key: vertex
                    // value : list í˜•íƒœë¡œ ì—°ê²°ëœ vertexë¥¼ í‘œë…€í•˜ì—¬ edge ì—°ê²° ê´€ê³„ í‘œí˜„
                    function ShortestPath() {
                       this.edges = {};
                    }
                    
                    // addVertex() : ì •ì  ì¶”ê°€ (ê°„ì„  ë¹„ìš© í‘œì‹œë¥¼ ìœ„í•´ key/value object í˜•íƒœë¡œ ì €ì¥)
                    ShortestPath.prototype.addVertex = function (vertex) {
                       this.edges[vertex] = {};
                    };
                    
                    // addEdge() : ê°„ì„  ì¶”ê°€
                    ShortestPath.prototype.addEdge = function (srcVertex, dstVertex, weight) {
                       this.edges[srcVertex][dstVertex] = weight;
                    };
                    
                    // _extractMin() : ìµœë‹¨ ê±°ë¦¬ ë…¸ë“œ ê²€ìƒ‰
                    ShortestPath.prototype._extractMin = function (queue, dist) {
                       let minDistance = Number.POSITIVE_INFINITY;
                       let minVertex = null;
                       
                       for (let vertex in queue) {
                          if (dist[vertex] <= minDistance) {
                             minDistance = dist[vertex];
                             minVertex = vertex;
                          }
                       }
                       
                       return minVertex;
                    };
           
           
              #ï¸âƒ£ Dijkstra ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
              
                  // dijkstra() : ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ ê²½ë¡œ íƒìƒ‰
                  ShotestPath.prototype.dijkstra = function (start) {
                     let queue = {};
                     let dist = {};
                     
                     for (let vertex in this.edges) {
                        dist[vertex] = Number.POSITIVE_INFINITY;
                        queue[vertex] = this.edges[vertex];
                     }
                     
                     dist[start] = 0;
                     while (Object.keys(queue).length != 0) {
                        let u = this._extractMin(queue, dist);
                        
                        delete queue[u];
                        
                        for (let neighbor in this.edges[u]) {
                           let alt = dist[u] + this.edges[u][neighbor];
                           if (alt < dist[neighbor]) dist[neighbor] = alt;
                        }
                     }
                     
                     for (let vertex in this.edges)
                        if (dist[vertex] === Number.POSITIVE_INFINITY)
                           delete dist[vertex];
                       
                     return dist;
                  };
                  
                  let path = new ShortestPath();
                  path.addVertex("A");
                  path.addVertex("B");
                  path.addVertex("C");
                  path.addVertex("D");
                  path.addVertex("E");
                  
                  path.addEdge("A", "B", 10);
                  path.addEdge("A", "C", 3);
                  path.addEdge("B", "C", 1);
                  path.addEdge("B", "D", 2);
                  path.addEdge("C", "B", 4);
                  path.addEdge("C", "D", 8);
                  path.addEdge("C", "E", 2);
                  path.addEdge("D", "E", 7);
                  path.addEdge("E", "D", 9);
                  
                  console.log(path);                        // ShortestPath {
                                                                  edges: {
                                                                     A: { B: 10, C: 3 },
                                                                     B: { C : 1, D : 2 },
                                                                     C: { B: 4, D: 8, E: 2 },
                                                                     D: { C: 7 },
                                                                     E: { D: 9 }
                                                                  }
                                                               }
                  
                  console.log(path.dijkstra("A"));          // { A: 0, B: 7, C: 3, D: 9, E: 5 }        
                  console.log(path.dijkstra("B"));          // { B: 0, C: 1, D: 2, E: 3 }
                  console.log(path.dijkstra("C"));          // { B: 4, C: 0, D: 6, E: 2 }
     
     
              #ï¸âƒ£ Floyd-Warshall ì•Œê³ ë¦¬ì¦˜
                    
                    : â­ë™ì  ê³„íšë²•â­ì„ í™œìš©í•´, ê·¸ë˜í”„ì—ì„œ â­ê°€ëŠ¥í•œ ëª¨ë“  ì •ì  ìŒì— ëŒ€í•´ ìµœë‹¨ ê±°ë¦¬â­ë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
                    
                    â­ ìŒì˜ ê°€ì¤‘ì¹˜ê°€ ìˆì–´ë„ ì‚¬ìš© ê°€ëŠ¥í•˜ë©°, ë§ì€ ìˆ˜ì˜ ê°„ì„ ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆëŠ” ë°€ì§‘ ê·¸ë˜í”„(Dense Graph)ì— ì‚¬ìš© ì í•©
                    
                    ğŸ”» êµ¬í˜„ ë©”ì„œë“œ(method)
                    
                          â—½ ì •ì /ê°„ì„  ì¶”ê°€ : ShortestPath.addVertex() / ShortestPath.addEdge()
                          
                          â—½ í”Œë¡œì´ë“œ-ì›Œì…œ ì•Œê³ ë¦¬ì¦˜ : ShortestPath.floydWarshall()
              
              
              #ï¸âƒ£ Floyd-Warshall ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ 
                  
                  // floydWarshall() : í”Œë¡œì´ë“œ-ì›Œì…œ ìµœë‹¨ ê²½ë¡œ íƒìƒ‰ 
                  ShortestPath.prototype.floydWarshall = function () {
                     let dist = {};
                     
                     for (let srcVertex in this.edges) {
                        dist[srcVertex] = {};
                        for (let dstVertex in this.edges) {
                           if (srcVertex === dstVertex) dist[srcVertex][dstVertex] = 0;
                           else dist[srcVertex][dstVertex] = Number.POSITIVE_INFINITY;
                        }
                     }
                     
                     for (let srcVertex in this.edges) {
                        for (let dstVertex in this.edges[srcVertex])
                           dist[srcVertex][dstVertex] = this.edges[srcVertex][dstVertex];
                     }
                     
                     for (let midVertex in this.edges)
                        for (let srcVertex in this.edges)
                           for (let dstVertex in this.edges)
                              dist[srcVertex][dstVertex] = Math.min(
                                 dist[srcVertex][dstVertex],
                                 dist[srcVertex][midVertex] + dist[midVertex][dstVertex]
                              };
                              
                     for (let srcVertex in this.edges)
                        for (let dstVertex in this.edges)
                           if (dist[srcVertex][dstVertex] === Number.POSITIVE_INFINITY)
                              delete dist[srcVertex][dstVertex];
                              
                     return dist;
                  };
                  
                  let path = new ShortestPath();
                  path.addVertex("A");
                  path.addVertex("B");
                  path.addVertex("C");
                  path.addVertex("D");
                  path.addVertex("E");
                  
                  path.addEdge("A", "B", 10);
                  path.addEdge("A", "C", 3);
                  path.addEdge("B", "C", 1);
                  path.addEdge("B", "D", 2);
                  path.addEdge("C", "B", 4);
                  path.addEdge("C", "D", 8);
                  path.addEdge("C", "E", 2);
                  path.addEdge("D", "E", 7);
                  path.addEdge("E", "D", 9);
                  
                  console.log(path);                            // ShortestPath {
                                                                      edges: {
                                                                        A: { B: 10, C: 3 },
                                                                        B: { C : 1, D : 2 },
                                                                        C: { B: 4, D: 8, E: 2 },
                                                                        D: { C: 7 },
                                                                        E: { D: 9 }
                                                                      }
                                                                   }     
                  
                  console.log(path.dijkstra("A"));              // { A: 0, B: 7, C: 3, D: 9, E: 5 } 
                  console.log(path.dijkstra("B"));              // { B: 0, C: 1, D: 2, E: 3 }
                  console.log(path.dijkstra("C"));              // { B: 4, C: 0, D: 6, E: 2 }
                  console.log(path.dijkstra("D"));              // { D: 0, E: 7 }
                  console.log(path.dijkstra("E"));              // { D: 9, E: 0 }
                  
                  console.log(path.floydWarshall());            // {
                                                                     A: { A: 0, B: 7, C: 3, D: 9, E: 5 }, 
                                                                     B: { B: 0, C: 1, D: 2, E: 3 },
                                                                     C: { B: 4, C: 0, D: 6, E: 2 },
                                                                     D: { D: 0, E: 7 },
                                                                     E: { D: 9, E: 0 }
                                                                   }
                 
                  
              #ï¸âƒ£ ë¶„í•  ì •ë³µ (Divide and Conquer)
              
                    : ë¬¸ì œë¥¼ ë‚˜ëˆŒ ìˆ˜ ì—†ì„ë•Œê¹Œì§€ â­ì‘ê²Œ ë‚˜ëˆ„ê³ , ë¶€ë¶„ ë¬¸ì œë¥¼ í•´ê²°í•˜ë©° ë³‘í•©â­í•´ í•´ë¥¼ ë„ì¶œí•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ì„¤ê¼ ê¸°ë²•
                    
                    ğŸŸ  ë¶„í•  ì •ë³µ íŠ¹ì§•
                    
                          â—½ í•˜ì–‘ì‹ ì ‘ê·¼ë²•ìœ¼ë¡œ ìƒìœ„ í•´ë‹µì„ êµ¬í•˜ê¸° ìœ„í•´ ì•„ë˜ë¡œ ë‚´ë ¤ê°€ë©´ì„œ ë‹µì„ ë„ì¶œ
                          
                          â—½ â­ë¶„í• í•œ ë¶€ë¶„ ë¬¸ì œê°€ ì„œë¡œ ì¤‘ë³µë˜ì§€ ì•Šì•„â­, ë¶€ë¬¸ í•´ í•´ê²° ì‹œ ìƒí˜¸ ì˜í–¥ ì—†ìŒ
             
              
              #ï¸âƒ£ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ
                  
                    
                    ğŸŸ¨ ë¬¸ì œ - ë¬¸ìì—´ ë‚´ pì™€ yì˜ ê°œìˆ˜   (* ë¬¸ì œ ì¶œì²˜ : í”„ë¡œê·¸ë˜ë¨¸ìŠ¤   https://programmers.co.kr/learn/courses/30/lessons/12916)
                    
                        ëŒ€ë¬¸ìì™€ ì†Œë¬¸ìê°€ ì„ì—¬ìˆëŠ” ë¬¸ìì—´ sê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. sì— 'p'ì˜ ê°œìˆ˜ì™€ 'yì˜ ê°œìˆ˜ë¥¼ ë¹„êµí•´ ê°™ìœ¼ë©´ True,
                        
                        ë‹¤ë¥´ë©´ Falseë¥¼ return í•˜ëŠ” solutionì„ ì™„ì„±í•˜ì„¸ìš”. 'p', 'y' ëª¨ë‘ í•˜ë‚˜ë„ ì—†ëŠ” ê²½ìš°ëŠ” í•­ìƒ Trueë¥¼ ë¦¬í„´í•©ë‹ˆë‹¤.
                        
                        ë‹¨, ê°œìˆ˜ë¥¼ ë¹„êµí•  ë•Œ ëŒ€ë¬¸ìì™€ ì†Œë¬¸ìëŠ” êµ¬ë³„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
                        
                        ì˜ˆë¥¼ ë“¤ì–´ sê°€ "pPoooyY"ë©´ trueë¥¼ returní•˜ê³  "Pyy"ë¼ë©´ falseë¥¼ returní•©ë‹ˆë‹¤.
                        
                    ğŸ”´ ì œí•œ ì‚¬í•­
                                
                          â—½ ë¬¸ìì—´ sì˜ ê¸¸ì´ : 50 ì´í•˜ì˜ ìì—°ìˆ˜
                          
                          â—½ ë¬¸ìì—´ sëŠ” ì•ŒíŒŒë²³ìœ¼ë¡œë§Œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
                          
                    ğŸŸ  ì…ì¶œë ¥ ì˜ˆ
                    
                          s              answer
                      "pPoooyY"           true
                      "Pyy"               false
                    
                    
                    ğŸ”» ë‚´ê°€ í‘¼ ë°©ë²•
                    
                        function solution(s){
                            var answer = true;

                            // 1. ëŒ€ì†Œë¬¸ì êµ¬ë³„í•˜ì§€ ì•Šê¸° ìœ„í•´ ëª¨ë‘ ëŒ€ë¬¸ìë¡œ ë³€ê²½
                            var str = s.toUpperCase();

                            // 2. pì™€ y count ì„¤ì •.
                            var countP = 0;
                            var countY = 0;

                            // 3. ë°˜ë³µë¬¸ìœ¼ë¡œ í•´ë‹¹ ê°’ì´ ì¡´ì¬í•˜ë©´ count ì¦ê°.
                            for (let i = 0; i < s.length; i++) {
                                if (str[i] == "P") {
                                    countP++;
                                } else if (str[i] == "Y") {
                                    countY++;
                                }
                            };

                            // pì™€ y ê°œìˆ˜ ë¹„êµí•´ì„œ ê°™ìœ¼ë©´ true ë°˜í™˜.
                            if (countP == countY) {
                                return answer;
                            } else {
                                return false;
                            }
                        }
                    
                  
                    ğŸ”» ë‹¤ë¥¸ ì‚¬ëŒ í’€ì´ ë°©ë²• (1)
                    
                        function numPY(s){
                            return s.toUpperCase().split("P").length === s.toUpperCase().split("Y").length;
                        }

                        // í…ŒìŠ¤íŠ¸ ì½”ë“œ
                        console.log( numPY("pPoooyY") )
                        console.log( numPY("Pyy")
                        
                        ğŸ’¡ split()ìœ¼ë¡œ í•´ë‹¹ ë¬¸ìì—´ë§Œ ì¶”ì¶œí•´ì„œ ê·¸ ê¸¸ì´ë¥¼ ë¹„êµí•œ ë°©ë²•ì´ ì°¸ì‹ í–ˆë‹¤!
                           split()ì„ ì•Œê³  ìˆì—ˆëŠ”ë°ë„, ë¬¸ìë¥¼ ìë¥´ëŠ”ê²ƒì˜ ì‚¬ìš©ë²•ë§Œ ìƒê°í–ˆì—ˆëŠ”ë° ì´ë ‡ê²Œ ê¸¸ì´ë¥¼ ë¹„êµí•˜ë©´ 
                           ê·¸ê±´ ê³§ ê°œìˆ˜ë¥¼ ë¹„êµí•˜ëŠ”ê²ƒê³¼ë„ ê°™ê¸°ë•Œë¬¸ì—, ì´ ë°©ë²•ë„ ë§¤ìš° ìœ ìš©í•œ ë°©ë²•ì¸ê²ƒ ê°™ë‹¤!
                    
                    
                    ğŸ”» ë‹¤ë¥¸ ì‚¬ëŒ í’€ì´ ë°©ë²• (2)
                        
                        function numPY(s) {
                          return s.match(/p/ig).length == s.match(/y/ig).length;
                        }

                        // í…ŒìŠ¤íŠ¸ ì½”ë“œ 
                        console.log( numPY("pPoooyY") )
                        console.log( numPY("Pyy") )                   
                        
                        ğŸ’¡ ì •ê·œ í‘œí˜„ì‹ìœ¼ë¡œ í•´ë‹¹ ë¬¸ìì—´ì„ ì°¾ê³  ê·¸ ê°œìˆ˜ë¥¼ ì„œë¡œ ë¹„êµí•œ ë°©ë²•.
                           ì •ê·œ í‘œí˜„ì‹ì—ì„œ match()ë¼ëŠ” ìƒˆë¡œìš´ ë©”ì†Œë“œë„ ì•Œê²Œ ëë‹¤!
                           ìœ ìš©í•˜ê²Œ ì‚¬ìš©í• ê²ƒ!
