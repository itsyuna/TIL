
[ê°œì¸ë³µìŠµ ë° ì¶”ê°€í•™ìŠµ]     + â­ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ê¸°

        
        ğŸ“‚ ì•Œê³ ë¦¬ì¦˜
        
              #ï¸âƒ£ Dijkstra ì•Œê³ ë¦¬ì¦˜
              
                    : ê·¸ë˜í”„ì—ì„œ â­ì¶œë°œì ê³¼ ë„ì°©ì  ì‚¬ì´ì˜ ìµœë‹¨ ê±°ë¦¬â­ë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
                    
                    â­ ë³´í†µ ë‹¨ì¼ ì •ì  ê°„ ìµœë˜ ê²½ë¡œ ì‚°ì¶œì‹œ ì‚¬ìš©, ë„ë¡œ êµí†µë§ì´ë‚˜ OSPFë“±ì˜ ë„¤íŠ¸ì›Œí¬ ë¼ìš°íŒ… í”„ë¡œí† ì½œì— ë„ë¦¬ ì´ìš©
                    
                    ğŸ”» êµ¬í˜„ ë©”ì„œë“œ(method)
                        
                          â—½ ì •ì /ê°„ì„  ì¶”ê°€: ShortestPath.addVertex() / ShortestPath.addEdge()
                          
                          â—½ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ : ShortestPath._extractMin() / ShortestPath.dijkstra()
                
                
              #ï¸âƒ£ Dijkstra ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ (1)
              
                    // ShortestPath() : edge object ê°ì²´ ì €ì¥ì„ ìœ„í•œ ìƒì„±ì
                    // key: vertex
                    // value : list í˜•íƒœë¡œ ì—°ê²°ëœ vertexë¥¼ í‘œë…€í•˜ì—¬ edge ì—°ê²° ê´€ê³„ í‘œí˜„
                    function ShortestPath() {
                       this.edges = {};
                    }
                    
                    // addVertex() : ì •ì  ì¶”ê°€ (ê°„ì„  ë¹„ìš© í‘œì‹œë¥¼ ìœ„í•´ key/value object í˜•íƒœë¡œ ì €ì¥)
                    ShortestPath.prototype.addVertex = function (vertex) {
                       this.edges[vertex] = {};
                    };
                    
                    // addEdge() : ê°„ì„  ì¶”ê°€
                    ShortestPath.prototype.addEdge = function (srcVertex, dstVertex, weight) {
                       this.edges[srcVertex][dstVertex] = weight;
                    };
                    
                    // _extractMin() : ìµœë‹¨ ê±°ë¦¬ ë…¸ë“œ ê²€ìƒ‰
                    ShortestPath.prototype._extractMin = function (queue, dist) {
                       let minDistance = Number.POSITIVE_INFINITY;
                       let minVertex = null;
                       
                       for (let vertex in queue) {
                          if (dist[vertex] <= minDistance) {
                             minDistance = dist[vertex];
                             minVertex = vertex;
                          }
                       }
                       
                       return minVertex;
                    };
           
           
              #ï¸âƒ£ Dijkstra ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
              
                  // dijkstra() : ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ ê²½ë¡œ íƒìƒ‰
                  ShotestPath.prototype.dijkstra = function (start) {
                     let queue = {};
                     let dist = {};
                     
                     for (let vertex in this.edges) {
                        dist[vertex] = Number.POSITIVE_INFINITY;
                        queue[vertex] = this.edges[vertex];
                     }
                     
                     dist[start] = 0;
                     while (Object.keys(queue).length != 0) {
                        let u = this._extractMin(queue, dist);
                        
                        delete queue[u];
                        
                        for (let neighbor in this.edges[u]) {
                           let alt = dist[u] + this.edges[u][neighbor];
                           if (alt < dist[neighbor]) dist[neighbor] = alt;
                        }
                     }
                     
                     for (let vertex in this.edges)
                        if (dist[vertex] === Number.POSITIVE_INFINITY)
                           delete dist[vertex];
                       
                     return dist;
                  };
                  
                  let path = new ShortestPath();
                  path.addVertex("A");
                  path.addVertex("B");
                  path.addVertex("C");
                  path.addVertex("D");
                  path.addVertex("E");
                  
                  path.addEdge("A", "B", 10);
                  path.addEdge("A", "C", 3);
                  path.addEdge("B", "C", 1);
                  path.addEdge("B", "D", 2);
                  path.addEdge("C", "B", 4);
                  path.addEdge("C", "D", 8);
                  path.addEdge("C", "E", 2);
                  path.addEdge("D", "E", 7);
                  path.addEdge("E", "D", 9);
                  
                  console.log(path);                        // ShortestPath {
                                                                  edges: {
                                                                     A: { B: 10, C: 3 },
                                                                     B: { C : 1, D : 2 },
                                                                     C: { B: 4, D: 8, E: 2 },
                                                                     D: { C: 7 },
                                                                     E: { D: 9 }
                                                                  }
                                                               }
                  
                  console.log(path.dijkstra("A"));          // { A: 0, B: 7, C: 3, D: 9, E: 5 }        
                  console.log(path.dijkstra("B"));          // { B: 0, C: 1, D: 2, E: 3 }
                  console.log(path.dijkstra("C"));          // { B: 4, C: 0, D: 6, E: 2 }
     
     
              #ï¸âƒ£ Floyd-Warshall ì•Œê³ ë¦¬ì¦˜
                    
                    : â­ë™ì  ê³„íšë²•â­ì„ í™œìš©í•´, ê·¸ë˜í”„ì—ì„œ â­ê°€ëŠ¥í•œ ëª¨ë“  ì •ì  ìŒì— ëŒ€í•´ ìµœë‹¨ ê±°ë¦¬â­ë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
                    
                    â­ ìŒì˜ ê°€ì¤‘ì¹˜ê°€ ìˆì–´ë„ ì‚¬ìš© ê°€ëŠ¥í•˜ë©°, ë§ì€ ìˆ˜ì˜ ê°„ì„ ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆëŠ” ë°€ì§‘ ê·¸ë˜í”„(Dense Graph)ì— ì‚¬ìš© ì í•©
                    
                    ğŸ”» êµ¬í˜„ ë©”ì„œë“œ(method)
                    
                          â—½ ì •ì /ê°„ì„  ì¶”ê°€ : ShortestPath.addVertex() / ShortestPath.addEdge()
                          
                          â—½ í”Œë¡œì´ë“œ-ì›Œì…œ ì•Œê³ ë¦¬ì¦˜ : ShortestPath.floydWarshall()
              
              
              #ï¸âƒ£ Floyd-Warshall ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ 
                  
                  // floydWarshall() : í”Œë¡œì´ë“œ-ì›Œì…œ ìµœë‹¨ ê²½ë¡œ íƒìƒ‰ 
                  ShortestPath.prototype.floydWarshall = function () {
                     let dist = {};
                     
                     for (let srcVertex in this.edges) {
                        dist[srcVertex] = {};
                        for (let dstVertex in this.edges) {
                           if (srcVertex === dstVertex) dist[srcVertex][dstVertex] = 0;
                           else dist[srcVertex][dstVertex] = Number.POSITIVE_INFINITY;
                        }
                     }
                     
                     for (let srcVertex in this.edges) {
                        for (let dstVertex in this.edges[srcVertex])
                           dist[srcVertex][dstVertex] = this.edges[srcVertex][dstVertex];
                     }
                     
                     for (let midVertex in this.edges)
                        for (let srcVertex in this.edges)
                           for (let dstVertex in this.edges)
                              dist[srcVertex][dstVertex] = Math.min(
                                 dist[srcVertex][dstVertex],
                                 dist[srcVertex][midVertex] + dist[midVertex][dstVertex]
                              };
                              
                     for (let srcVertex in this.edges)
                        for (let dstVertex in this.edges)
                           if (dist[srcVertex][dstVertex] === Number.POSITIVE_INFINITY)
                              delete dist[srcVertex][dstVertex];
                              
                     return dist;
                  };
                  
                  let path = new ShortestPath();
                  path.addVertex("A");
                  path.addVertex("B");
                  path.addVertex("C");
                  path.addVertex("D");
                  path.addVertex("E");
                  
                  path.addEdge("A", "B", 10);
                  path.addEdge("A", "C", 3);
                  path.addEdge("B", "C", 1);
                  path.addEdge("B", "D", 2);
                  path.addEdge("C", "B", 4);
                  path.addEdge("C", "D", 8);
                  path.addEdge("C", "E", 2);
                  path.addEdge("D", "E", 7);
                  path.addEdge("E", "D", 9);
                  
                  console.log(path);                            // ShortestPath {
                                                                      edges: {
                                                                        A: { B: 10, C: 3 },
                                                                        B: { C : 1, D : 2 },
                                                                        C: { B: 4, D: 8, E: 2 },
                                                                        D: { C: 7 },
                                                                        E: { D: 9 }
                                                                      }
                                                                   }     
                  
                  console.log(path.dijkstra("A"));              // { A: 0, B: 7, C: 3, D: 9, E: 5 } 
                  console.log(path.dijkstra("B"));              // { B: 0, C: 1, D: 2, E: 3 }
                  console.log(path.dijkstra("C"));              // { B: 4, C: 0, D: 6, E: 2 }
                  console.log(path.dijkstra("D"));              // { D: 0, E: 7 }
                  console.log(path.dijkstra("E"));              // { D: 9, E: 0 }
                  
                  console.log(path.floydWarshall());            // {
                                                                     A: { A: 0, B: 7, C: 3, D: 9, E: 5 }, 
                                                                     B: { B: 0, C: 1, D: 2, E: 3 },
                                                                     C: { B: 4, C: 0, D: 6, E: 2 },
                                                                     D: { D: 0, E: 7 },
                                                                     E: { D: 9, E: 0 }
                                                                   }
                 
                  
              #ï¸âƒ£ ë¶„í•  ì •ë³µ (Divide and Conquer)
              
                    : ë¬¸ì œë¥¼ ë‚˜ëˆŒ ìˆ˜ ì—†ì„ë•Œê¹Œì§€ â­ì‘ê²Œ ë‚˜ëˆ„ê³ , ë¶€ë¶„ ë¬¸ì œë¥¼ í•´ê²°í•˜ë©° ë³‘í•©â­í•´ í•´ë¥¼ ë„ì¶œí•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ì„¤ê¼ ê¸°ë²•
                    
                    ğŸŸ  ë¶„í•  ì •ë³µ íŠ¹ì§•
                    
                          â—½ í•˜ì–‘ì‹ ì ‘ê·¼ë²•ìœ¼ë¡œ ìƒìœ„ í•´ë‹µì„ êµ¬í•˜ê¸° ìœ„í•´ ì•„ë˜ë¡œ ë‚´ë ¤ê°€ë©´ì„œ ë‹µì„ ë„ì¶œ
                          
                          â—½ â­ë¶„í• í•œ ë¶€ë¶„ ë¬¸ì œê°€ ì„œë¡œ ì¤‘ë³µë˜ì§€ ì•Šì•„â­, ë¶€ë¬¸ í•´ í•´ê²° ì‹œ ìƒí˜¸ ì˜í–¥ ì—†ìŒ
             
              
              #ï¸âƒ£ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ
                  
                    
                    ğŸŸ¨ 
                    
                    ğŸŸ¨
                
                  

    
