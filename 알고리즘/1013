
[개인복습 및 추가학습]


      📂 알고리즘
    
              #️⃣ 정렬 알고리즘

                    ⭐ 컴퓨터 사이언스 분야에서 가장 많이 쓰이는 알고리즘!

                    : 배열 내 원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘이다.

                    🔻 대표 정렬 알고리즘

                        🟠 거품 정렬 / 선택 정렬                -> 시간 복잡도 O(n제곱)을 갖는 정렬.

                        🟠 삽입 정렬 / 병합 정렬 / 퀵 정렬       -> 시간 복잡도 O(n log n)을 갖는 정렬.


                   🟡 거품 정렬 (Bubble Sort)

                      : 동작 매커니즘이 서로 인접한 두 원소를 비교하면서 정렬하는 알고리즘.

                      ⭐ 뒷쪽부터 정렬되는 알고리즘!


                      🔻 알고리즘 동작 방식

                            1. 인접한 값을 비교해서, 큰 값이면 서로 교환한다.

                            2. index N까지 반복.

                            3. N차례 반복한다. -> N-i


                      🟩 구현 예제 복습          * 1011 학습내용 코드 참고

                           let swap = function (arr, idx_1, idx_2) {
                              let tmp = arr[idx_i];
                              arr[idx_1] = arr[idx_2];
                              arr[idx_2] = tmp;
                           };

                           let ascending = function (x, y) {
                              return x > y;
                           };

                           let descending = function (x, y) {
                              return x < y;
                           };

                           let bubbleSort = fuction (arr, compare) [
                              for (let i = 0; i < arr.length - 1; i+) {
                                 for (let j = 0; j < arr.length - i - 1; j++) {
                                    if (compare[arr[j], arr[j + 1])) {
                                       swap(arr, j, j + 1);
                                    }
                                 }
                              }
                           };

                           /* test code */
                           let init_array = [6, 5, 1, 3, 2, 4];
                           let array;

                           let sorting = [bubbleSort];
                           let order = [ascending, descending];
                           for (let i = 0; i < sorting.length; i++) {
                              for (let j = 0; j < order.length; j++) {
                                 console.log(sorting[i].name, order[j].name);

                                 array = [...init_array];
                                 sorting[i](array, order[j]);
                                 console.log(array);
                              }
                           }
                     
                     
                    🟡 선택 정렬 (Selection Sort)
                    
                        : 최소값을 찾아서 데이터 영역의 가장 앞으로 이동하는 방식을 반복하여 전체 데이터 영역을 정렬하는 알고리즘이다. 
                    
                        ⭐ 앞에서부터 정렬!
                        
                        
                        🔻 알고리즘 동작 순서
                        
                              1. 교환 위치를 선택한다.
                              
                              2. 최소값을 탐색한다.
                              
                              3. 교환한다.
                      
                    
                    🟡 삽입 정렬 (Insertion Sort)
                    
                        : 이미 정렬된 데이터 영역과 비교하면서, 자신의 위치를 찾아 요소를 삽입하며 정렬하는 알고리즘이다.
                        
                        ⭐ 앞에서부터 정렬!
                        
                        
                        🔻 알고리즘 동작 순서
                        
                              1. 요소를 선택하고 저장한다.
                              
                              2. shift를 하고, 값을 비교해서 삽입 위치를 선택한다.
                              
                              3. 요소를 삽입한다.
                        
                        
                    🟡 병합 정렬 (Merge Sort)
                    
                         : 하나의 배열을 두 개의 균등한 크기로 분할하고, 부분 정렬해서 이를 다시 합하면서 전체를 정렬해가는 알고리즘이다.
                         
                         ⭐ 평균 시간 복잡도 O(n log n)으로 위에 정렬들보다 조금 더 빠르다!
                        
                         
                         🔻 알고리즘 동작 순서
                         
                            -> 크게 '분할'과 '정렬', 이렇게 2가지 파트로 나눠지게 된다.
                      
                      
                     🟡 퀵 정렬 (Quick Sort)
                     
                          : 특정한 값(pivot)을 기준으로 큰 숫자와 작은 숫자를 분할하여 정렬하는 알고리즘이다.
                          
                          ⭐ 퀵 정렬도 평균 시간 복잡도 O(n log n)을 가지고 있다!
                          
                          
                          🔻 알고리즘 동작 순서
                          
                                1. 기준에 따라서 분할한다.
                                
                                2. 부분 배열 정렬을 한다.
                                
                                3. 전체 정렬을 한다.
                          
                          🟣 구현 방법들중에, qsort() 방식.
                          
                                -> 총 3가지 변수를 사용한다.
                                
                                ● pivot : 기준점이 된다.
                                
                                ● start : 최초로 비교할 위치.
                                
                                ● target : 비교 대상
                                
                                ⭐ target과 pivot을 비교해서, 만약 target이 pivot보다 작으면
                                   start와 target이 swap을 한다.
                   
                   
                   ⭐⭐ 위의 방법들로 성능 측정(benchmark)을 했을 때,
                         퀵 정렬이 제일 빠르고, 거품 정렬이 제일 느리다. 그리고 거품 정렬중에서는, 오름차순보다 내림차순이 더 느리다.
                          
                          
              #️⃣ 이진 검색 (Binary Search)
              
                    ⭐ 검색은 정렬과 함께 많이 쓰이는 알고리즘 중 하나이다!
                    
                    ⭐ 평균 시간 복잡도 : O(log n)
                    
                    : 자료구조 기반으로 정렬되어 있는 데이터 안에서, 특정 값을 찾는 기법을 말한다.
                    
                    
                    🔻 구현 방법 및 메서드(method)
                    
                        🟡 binarySearch_loop()        : 반복문을 이용한 검색
                        
                        🟡 binarySearch.recursive()   : 재귀를 이용한 검색
                    
              
              #️⃣ 탐욕 알고리즘 (Greedy Algorithm)
              
                    : 매 순간 최적의 해를 선택하면서, 최종적으로 최적의 해에 도달하는 알고리즘 설계 기법을 말한다.
                    
                    🔴 탐욕 알고리즘 특징
                    
                        1. '최적 부분 구조'나 '탐욕 선택 속성' 문제를 해결하는데 적합하다.
                        
                            ◽ 최적 부분 구조 : 어떤 문제의 최적의 해결책이 그 부문 문제에 최적의 해결책으로부터 설계될 수 있는 경우를 말한다.
                            
                            ◽ 탐욕 선택 속성 : 주어진 조건에 따라서 제일 적합한 경우의 수를 선택하는것을 말한다. 
                       
                        2. 매 순간 최적의 해를 찾으면서 구하는 방법이, 항상 최적임을 보장하지 않아서 유의 필요. 
                   
                   
                   
                   
                   
              #️⃣ 백트래킹 
              
                     : 경우의 수로 해를 찾는 도중에, 해가 나올 수 없는 조건일 때 이를 중단하고 다른 경우의 수로 해를 찾는 알고리즘 기법.
                    
                     🔴 백트래킹 특징
                     
                          1. 해가 될 가능성이 있으면 지속적 탐색, 가능성이 없다면 가지치기(pruning)하여 빠르게 전체 해를 탐색한다.
                          
                          2. 해가 되지 않는 경우의 수는 배재하여, 해를 찾는 시간 복잡도를 단축한다.
              
              
              #️⃣
              #️⃣
              #️⃣
              #️⃣          
                  
                  
                  
