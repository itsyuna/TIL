
ğŸ“‚ ë¹„ì„ í˜• ìë£Œêµ¬ì¡°

    ğŸ¥ ì˜¤ëŠ˜ì˜ ëª©í‘œ : DFT / BFS / í™ / íŠ¸ë¼ì´ ìµíˆê¸°!
    
    
       #ï¸âƒ£ DFS (Depth First Search)     â­ BFSì™€ ê°™ì´ ì •ë§ ë§ì´ ì“°ì´ëŠ” ì•Œê³ ë¦¬ì¦˜, íƒìƒ‰ ê¸°ë²•ì¤‘ í•˜ë‚˜ì´ë‹¤. 
       
              â— íŠ¸ë¦¬ë‚˜ ê·¸ë˜í”„ ë“±ì—ì„œ í•˜ë‚˜ì˜ ìµœëŒ€í•œ ê¹Šê²Œ ë“¤ì–´ê°€ë©´ì„œ í•´ë¥¼ ì°¾ëŠ” íƒìƒ‰ ê¸°ë²•

              â— ì¥/ë‹¨ì 

                 â—½ ì¥ì : ì¸ì ‘í•œ í›„ë³´ ë…¸ë“œë§Œ ê¸°ì–µí•˜ë©´ ë˜ë¯€ë¡œ ì ì€ ê¸°ì–µê³µê°„ ì†Œìš”, ë…¸ë“œê°€ ê¹Šì€ ë‹¨ê³„ì— ìˆì„ ê²½ìš° ë¹ ë¥´ê²Œ ì •ë‹µ ì‚°ì¶œ 

                 â—½ ë‹¨ì : ì„ íƒí•œ ê²½ë¡œê°€ ë‹µì´ ì•„ë‹ ê²½ìš° ë¶ˆí•„ìš”í•œ íƒìƒ‰ ê°€ëŠ¥, ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•  ì‹œ ì°¾ì€ í•´ê°€ ì •ë‹µì´ ì•„ë‹ ê²½ìš° ë°œìƒ

              â— êµ¬í˜„ ë©”ì„œë“œ(method)

                 â—½ ì¬ê·€ë¥¼ ì´ìš©í•œ íƒìƒ‰: Graph._dfsRecursiveVisit()

                 â—½ ìŠ¤íƒì„ ì´ìš©í•œ íƒìƒ‰: Graph._dfsLoopVisit()
       
      
       #ï¸âƒ£ DFS êµ¬í˜„í•˜ê¸° - 1
       
                ğŸ”» ì˜ˆì œ

                    // dfs(): DFS íƒìƒ‰
                    Graph.prototype.dfs = function (startVertex) {
                       this._dfsRecursiveVisit(startVertex);
                    };

                    // _dfsRecursiveVisit(): ì¬ê·€ë¥¼ ì´ìš©í•œ DFS íƒìƒ‰
                    Graph.prototype._dfsRecursiveVisit = function (vertex) {
                       // 1. ì¢…ë£Œ ì¡°ê±´
                       if (this.visited[vertex] {
                          return;
                       }

                       // 2. ì¬ê·€ í˜¸ì¶œì„ í•˜ë©´ì„œ ìˆ˜í–‰í•´ì•¼í•  ì½”ë“œ 
                       this.visited[vertex] = true;
                       console.log(`visit "${vertex}"`);

                       let neighbors = this.edge[vertex];
                       for (let i = 0; i < neighbors.length; i++) {
                          this._dfsRecursiveVisit(neighbors[i]);
                       }
                    };

                    let graph = new Graph();
                    let vertices = ["A", "B", "C", "D", "E", "F", "G", "H", "I"];

                    for (let i = 0; i < vertices.length; i++) {
                       graph.addVertex(vertices[i]);
                    }

                    graph.addEdge("A", "B");
                    graph.addEdge("A", "C");
                    graph.addEdge("A", "D");
                    graph.addEdge("C", "G");
                    graph.addEdge("D", "G");
                    graph.addEdge("D", "H");
                    graph.addEdge("B", "E");
                    graph.addEdge("B", "F");
                    graph.addEdge("E", "I");
                    graph.print();                          // A -> B C D
                                                               B -> E F
                                                               C -> G
                                                               D -> G H
                                                               E -> I
                    console.log("");

                    graph.dfs("A");                        // visit "A"
                                                              visit "B"
                                                              visit "E"
                                                              visit "I"
                                                              visit "F"
                                                              visit "C"
                                                              visit "G"
                                                              visit "D"
                                                              visit "H"
          
          
       #ï¸âƒ£ DFS êµ¬í˜„í•˜ê¸° - 2
       
                ğŸ”» ì˜ˆì œ

                    import { Stack } from "./stack.mjs";

                    // dfs(): DFS íƒìƒ‰
                    Graph.prototype.dfs = function (startVertex) {
                       // this._dfsRecursiveVisit(startVertex);
                       this._dfsLoopVisit(startVertex);
                    };

                    // _dfsLoopVisit(): ìŠ¤íƒì„ ì´ìš©í•œ DFS íƒìƒ‰
                    Graph.prototype._dfsLoopVisit = function (vertex) {
                       let stack =  new Stack();
                       stack.push(vertex);

                       while (!stack.isEmpty()) {
                          let vertex = stack.pop();
                          if (this.visited[vertex]) {
                             continue;
                          }

                          this.visited[vertex] = true;
                          console.log(`visit "${vertex}"`);

                          let neighbors = this.edge[vertex];
                          for (let i = neighbors.length - 1; i >= 0; i--) {
                             stack.push(neighbors[i]);
                          }
                       }
                    };

                    let graph = new Graph();
                    let vertices = ["A", "B", "C", "D", "E", "F", "G", "H", "I"];

                    for (let i = 0; i < vertices.length; i++) {
                       graph.addVertex(vertices[i]);
                    }

                    graph.addEdge("A", "B");
                    graph.addEdge("A", "C");
                    graph.addEdge("A", "D");
                    graph.addEdge("C", "G");
                    graph.addEdge("D", "G");
                    graph.addEdge("D", "H");
                    graph.addEdge("B", "E");
                    graph.addEdge("B", "F");
                    graph.addEdge("E", "I");
                    graph.print();                            // A -> B C D
                                                                 B -> E F
                                                                 C -> G
                                                                 D -> G H
                                                                 E -> I
                    console.log("");

                    graph.dfs("A");                           // visit "A"
                                                                 visit "B"
                                                                 visit "E"
                                                                 visit "I"
                                                                 visit "F"
                                                                 visit "C"
                                                                 visit "G"
                                                                 visit "D"
                                                                 visit "H"
            
       
       #ï¸âƒ£ BFS (Breadth First Search)
       
                â— íŠ¸ë¦¬ë‚˜ ê·¸ë˜í”„ ë“±ì—ì„œ ì¸ì ‘í•œ ë…¸ë“œë¥¼ ìš°ì„  ë°©ë¬¸í•˜ë©´ì„œ ë„“ê²Œ ì›€ì§ì´ë©° í•´ë¥¼ ì°¾ëŠ” íƒìƒ‰ ê¸°ë²•

                â— ì¥/ë‹¨ì 

                   â—½ ì¥ì : ìµœë‹¨ ê²½ë¡œ íƒìƒ‰ì—ì„œ êµ¬í•œ í•´ê°€ ì •ë‹µì„ì„ ë³´ì¥

                   â—½ ë‹¨ì : ê²½ë¡œê°€ ë§¤ìš° ê¸¸ì–´ì§ˆ ê²½ìš°, íƒìƒ‰ ë²”ìœ„ê°€ ì¦ê°€í•˜ë©´ì„œ DFSë³´ë‹¤ ë§ì€ ê¸°ì–µ ê³µê°„ì´ í•„ìš”

                â— êµ¬í˜„ ë©”ì„œë“œ(method)

                   â—½ íë¥¼ ì´ìš©í•œ íƒìƒ‰: Graph.bfs(), Graph._bfsLoopVisit()

                   â—½ ìµœë‹¨ ê²½ë¡œ íƒìƒ‰: Graph.shortestPath(), Graph._bfsShortestPath(), Graph._from_to_path()
       
       
       #ï¸âƒ£ BFS êµ¬í˜„í•˜ê¸° - 1
       
                 ğŸ”» ì˜ˆì œ

                    import { Queue } from "./queue.mjs";

                    // bfs(): BFS íƒìƒ‰
                    Graph.prototype.bfs = function (startVertex) {
                       this._bfsLoopVisit(startVertex);
                    };

                    // _bfsLoopVisit(): íë¥¼ ì´ìš©í•œ BFS íƒìƒ‰
                    Graph.prototype._bfsLoopVisit = function (vertex) {
                       let queue = new Queue();
                       queue.enqueue(vertex);

                       while (!queue.isEmpty()) {
                          let vertex = queue.dequeue();
                          if (this.visited[vertex]) {
                             continue;
                          }

                          this.visited[vertex] = true;
                          console.log(`visit "${vertex}"`);

                          let heighbors = this.edge[vertex];
                          for (let i = 0; i < neighbors.length; i++) {
                             queue.enqueue(heighbors[i]);
                          }
                       }
                    };

                    let graph = new Graph();
                    let vertices = ["A", "B", "C", "D", "E", "F", "G", "H", "I"];

                    for (let i = 0; i < vertices.length; i++) {
                       graph.addVertex(vertices[i]);
                    }

                    graph.addEdge("A", "B");
                    graph.addEdge("A", "C");
                    graph.addEdge("A", "D");
                    graph.addEdge("C", "G");
                    graph.addEdge("D", "G");
                    graph.addEdge("D", "H");
                    graph.addEdge("B", "E");
                    graph.addEdge("B", "F");
                    graph.addEdge("E", "I");
                    graph.print();                      // A -> B C D
                                                           B -> E F
                                                           C -> G
                                                           D -> G H
                                                           E -> I
                    console.log("");

                    graph.bfs("A");                    // visit "A"
                                                          visit "B"
                                                          visit "C"
                                                          visit "D"
                                                          visit "E"
                                                          visit "F"
                                                          visit "G"
                                                          visit "H"
                                                          visit "I"

       
       #ï¸âƒ£ BFS êµ¬í˜„í•˜ê¸° - 2
       
                ğŸ”» ì˜ˆì œ

                    // _bfsShortestPath(): ë‹¤ë¥¸ ì •ì  ê°„ ìµœë‹¨ ê²½ë¡œ ë¹„ìš© ì‚°ì¶œ
                    Graph.prototype._bfsShortestPath = function (vertex) {
                       let queue = new Queue();
                       queue.enqueue(vertex);

                       let distance = {};
                       let pre_visit = {};
                       for (let vertex in this.edge) {
                          distance[vertex] = 0;
                          pre_visit[vertex] = null;
                       }

                       while (!queue.isEmpty()) {
                          let vertex = queue.dequeue();

                          this.visited[vertex] = true;
                          console.log(`visit "${vertex}"`);

                          let heighbors = this.edge[vertex];
                          for (let i = 0; i < heighbors.length; i++) {
                             if (!this.visited[neighbors[i]]) {
                                distance[neighbors[i]] = distance[vertex] + 1;
                                pre_visit[neighbors[i]] = vertex;
                                queue.enqueue(heighbors[i]);
                             }
                          }
                       }

                       return { distance, pre_visit };
                    };

                    let graph = new Graph();
                    let vertices = ["A", "B", "C", "D", "E", "F", "G", "H", "I"];

                    for (let i = 0; i < vertices.length; i++) {
                       graph.addVertex(vertices[i]);
                    }

                    graph.addEdge("A", "B");
                    graph.addEdge("A", "C");
                    graph.addEdge("A", "D");
                    graph.addEdge("C", "G");
                    graph.addEdge("D", "G");
                    graph.addEdge("D", "H");
                    graph.addEdge("B", "E");
                    graph.addEdge("B", "F");
                    graph.addEdge("E", "I");
                    graph.print();
                    console.log("");

                    console.log(graph._bfsSHortestPath("A"));         // visit "A"
                                                                         {
                                                                           distance: { A: 0, B: 0, C: 0, D: 0, E: 0, G: 0, H: 0, I: 0 },
                                                                           pre_visit: {
                                                                              A: null,
                                                                              B: null,
                                                                              C: null,
                                                                              D: null,
                                                                              E: null,
                                                                              F: null,
                                                                              G: null,
                                                                              H: null,
                                                                              I: null
                                                                           }
                                                                         }
           
           
       #ï¸âƒ£ BFS êµ¬í˜„í•˜ê¸° - 3
       
                ğŸ”» ì˜ˆì œ

                    // _from_to_path(): from ì •ì ì—ì„œ to ì •ì ìœ¼ë¡œ ìµœë‹¨ ê²½ë¡œ ì¶œë ¥
                    Graph.prototype._from_to_path = function (pre_visit, from, to)
                    {
                       let stack = new Stack();

                       for (let v = to; v !== from; v = pre_visit[v]) {
                          stack.push(v);
                       }
                       stack.push(from);

                       while (!stack.isEmpty()) {
                          let v = stack.pop();
                          process.stdout.wrtie(`${v} -> `);
                       }
                       console.log("end");
                    };  

                    // shortestPath(): ë‹¤ë¥¸ ì •ì  ê°„ ìµœë‹¨ ê²½ë¡œ íƒìƒ‰
                    Graph.prototype.shortestPath = function (startVertex) {
                       let result = this._bfsShortestPath(startVertex);

                       console.log(result.distance);
                       console.log(result.pre_visit);

                       for (let vertex in this.edge) {
                          if (vertex === startVertex) continue;

                          this._from_to_path(result.pre_visit, startVertex, vertex);
                       }
                    };

                    let graph = new Graph();
                    let vertices = ["A", "B", "C", D", "E", "F", "G", "H", "I"];

                    for (let i = 0; i < vertices.length; i++) {
                       graph.addVertex(vertices[i]);
                    }

                    graph.addEdge("A", "B");
                    graph.addEdge("A", "C");
                    graph.addEdge("A", "D");
                    graph.addEdge("C", "G");
                    graph.addEdge("D", "G");
                    graph.addEdge("D", "H");
                    graph.addEdge("B", "E");
                    graph.addEdge("B", "F");
                    graph.addEdge("E", "I");
                    graph.print();
                    console.log("");

                    graph.shortestPath("A");                      // A -> B -> end
                                                                     A -> C -> end
                                                                     A -> D -> end
                                                                     A -> B -> E -> end
                                                                     A -> B -> F -> end
                                                                     A -> D -> G -> end
                                                                     A -> d -> H -> end
                                                                     A -> B -> E -> I -> end
                       
                
       #ï¸âƒ£ í™ (Heap)     
       
                â— ìµœëŒ“ê°’ í˜¹ì€ ìµœì†Ÿê°’ì„ ë¹ ë¥´ê²Œ ì°¾ê¸° ìœ„í•´ ì™„ì „ì´ì§„íŠ¸ë¦¬ í˜•íƒœë¡œ ì—°ì‚°ì„ ìˆ˜í–‰í•˜ëŠ” ìë£Œêµ¬ì¡°

                â— í™ ëŒ€í‘œ ì†ì„±

                    â—½ ì •ë ¬: ê° ë…¸ë“œì˜ ê°’ì€ ìì‹ ë…¸ë“œê°€ ê°€ì§„ ê°’ë³´ë‹¤ ì‘ê±°ë‚˜ í˜¹ì€ í° ìˆœì„œëŒ€ë¡œ ì •ë ¬

                    â—½ í˜•íƒœ: íŠ¸ë¦¬ì˜ í˜•íƒœëŠ” ì™„ì „ì´ì§„íŠ¸ë¦¬(complete binary tree) ëª¨ì–‘

                â— í™ ì¢…ë¥˜

                    â—½ ìµœì†Œ í™ (Min Heap): ë¶€ëª¨ ë…¸ë“œì˜ ê°’ì´ ìì‹ ë…¸ë“œì˜ ê°’ë³´ë‹¤, ì‘ê±°ë‚˜ ê°™ì€ ì™„ì „ ì´ì§„ íŠ¸ë¦¬

                    â—½ ìµœëŒ€ í™ (Max Heap): ë¶€ëª¨ ë…¸ë“œì˜ ê°’ì´ ìì‹ ë…¸ë“œì˜ ê°’ë³´ë‹¤, í¬ê±°ë‚˜ ê°™ì€ ì™„ì „ ì´ì§„ íŠ¸ë¦¬

                â— í™ êµ¬í˜„

                    â—½ ì™„ì „ì´ì§„íŠ¸ë¦¬ ì„±ì§ˆì„ ë§Œì¡±í•˜ê¸° ë•Œë¬¸ì— 1ì°¨ì› ë°°ì—´ë¡œ í‘œí˜„ ê°€ëŠ¥

                    â—½ í˜„ì¬ ë…¸ë“œ: N, ë¶€ëª¨ ë…¸ë“œ: (N-1)/2, ì™¼ìª½ ìì‹ë…¸ë“œ: (N * 2)+1, ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œ: (N*2)+2

                â— êµ¬í˜„ ë©”ì„œë“œ(method)

                    â—½ ë…¸ë“œ ìœ„ì¹˜ ê³„ì‚°: Heap.paretnIndex(), Heap.leftChildInex(), Heap.rightChildIndex()

                    â—½ ë…¸ë“œ ê°’ í™•ì¸: Heap.parentIndex(), Heap.leftChildIndex(), Heap.rightChildIndex()

                    â—½ ë…¸ë“œ ì¶”ê°€/ì‚­ì œ(ì¶”ì¶œ): Heap.insert(), Heap.bubbleUp(), Heap.extract(), Heap.bubbleDown()

       
        #ï¸âƒ£ íŠ¸ë¼ì´ (Trie)
        
                â— íƒìƒ‰ íŠ¸ë¦¬ì˜ ì¼ì¢…ìœ¼ë¡œ, ë¬¸ìì—´ì´ë‚˜ ì—°ê´€ ë°°ì—´ì„ ì €ì¥í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” íŠ¸ë¦¬ ìë£Œ êµ¬ì¡°

                â— íŠ¸ë¼ì´ íŠ¹ì§•

                    â—½ ë¬¸ìì—´ ê²€ìƒ‰ì— íŠ¹í™”ëœ ìë£Œêµ¬ì¡°

                    â—½ ë¬¸ìì—´ ê¸¸ì´ê°€ Mì¼ ê²½ìš° O(M)ì˜ ì‹œê°„ ë³µì¡ë„ë¡œ ê²€ìƒ‰ ê°€ëŠ¥

                â— êµ¬í˜„ ë©”ì„œë“œ(method)

                    â—½ ë°ì´í„° ì¶”ê°€ / ê²€ìƒ‰ / ì‚­ì œ: Trie.insert(), Trie.search(), Trie.delete()
            
       
       
       
