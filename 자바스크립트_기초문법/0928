
📂 자바스크립트 기초문법

    🐥 오늘의 목표 : 조건문, 반복문, 함수, 배열 익히기.
    
    
    1️⃣3️⃣ 비교 / 논리 연산자          ⭐ 조건문에서 많이 사용된다. 
      
      
        🔎 비교 연산자
            
            ● 좌항과 우항의 피연산자를 비교한 다음 결과값을 논리적 자료형으로 반환하는 연산자
            ● ==은 단순 값의 같음을 비교하는 동등 비교, ===는 자료형까지 같음을 판단하는 일치 비교 연산자
            
               a > b        :  a가 b보다 크면 true, 아니면 false
               
               a < b        :  a가 b보다 작으면 true, 아니면 false
               
               a >= b       :  a가 b보다 크거나 같으면 true, 아니면 false
               
               a <= b       :  a가 b보다 작거나 같으면 true, 아니면 false
               
               a == b       :  a와 b가 같으면 true, 아니면 false    ⭐ ==는 값에 대한 casting(형변환)까지 해줘서 같은지를 비교. 
               
                    Ex) 5 == '5'     -> true                       ⭐ 데이터가 달라도 자동으로 형변환이 되기 때문에, 값에 대한 본질은 같다라고 판단해서 true이다.
               
               a != b  :  a와 b가 같지 않으면 true, 아니면 false
               
                    Ex) 5 != '5'     -> false
               
               a === b   :  a와 b의 자료형과 값이 같으면 true, 아니면 false
               
                    Ex) 5 === '5'     -> false                     ⭐ ===는 casting이 안되고, 자료형까지 같은지를 체크해서 좀 더 완벽하게 일치하는지 비교.
               
               a !== b   :  a와 b의 자료형과 값이 다르면 true, 아니면 false
                  
                    Ex) 5 !== '5'     -> true
        
                  
                  🔻 예시
                  
                      console.log("Z" > "A");         // true   -> A가 Z보다 순서상 위에 있기 때문에, Z가 산술적으로 더 크다라고 계산한다. 
                      
                      console.log("Hello" < "Hi");    // true     ⭐ H는 똑같기 때문에, 2번째에 대한 비교를 한다. 
                                                                     e보다 i가 좀 더 순서가 뒤에 있기 때문에, i가 크다라고 판단해서 true 값을 리턴한다.  
                      
                      console.log("Hello" >= "Helloo");     // false    ⭐ 앞에 hello까지는 동일하나, 오른쪽에 o가 하나 더 있기 때문에 이 문자열이 좀 더 크다라고 판단한다.
                                                                        문자열의 비교는 첫번째부터 순차적으로 비교한다.
                                                                        
                                                                        그래서 console.log("ZA" > "AAAA");   같은경우,
                                                                        오른쪽이 문자가 더 길다고 하더라도,
                                                                        첫번째 글자부터 비교하기 때문에, Z가 더 커서 이것도 true값이 나온다. 
                                                                          
                                                                        -> 문자열에 대한 비교는, 첫번째부터 비교를해서
                                                                        이미 비교가 이 시점에 끝나면 논리적인 연산이 종료된다.   -> 이미 결과값이 단정지어 진다. 
                      
                      console.log("5" <= 10);         // true           ⭐ 문자열과 숫자의 비교 
                      
                      console.log(true == 1);         // true
                      
                      console.log(false != 123);      // true           ⭐ 123은 변환을 하게 되면 true이기 때문에, 같지 않다. 
                      
                      console.log(true === 1);        // false          ⭐ 두 개의 값에 대한 본질은 같지만, 일치비교이기 때문에 각각의 타입이 다르므로 false가 나온다. 
                      
                      console.log(false !== 123);     // true         ⭐ 이건 이미 값이 다르지 않더라도, type이 다르기 때문에 false가 나온다. 
                      
                      
         🔎 논리 연산자
         
              ● 좌항과 우항의 피연산자 간 논리 값을 연산하여 참 또는 거짓을 결과로 얻는 연산자
              ● 논리 연산자: &&(AND), ||(OR), !(NOT)
              
              🔻 논리 연산자 예제
              
                  console.log(true || false);     // true       ⭐ OR은 둘 중 하나라도 true이면 true이기 때문에, true가 나온다. 
                  
                  console.log(Boolean(0 || false));       // false
                  
                  console.log(Boolean(123 || false));     // true
                  
                  console.log(Boolean(123 && 0));         // false
                  
                  console.log(Boolean(false && true));    // false
                  
                  console.log(Boolean(true && 3));        // true
                  
                  console.log(Boolean(0 && false));       // false
                  
                  console.log(!false);              // true
                  
                  console.log(!123);              // false
         
            
    1️⃣4️⃣ SCOPE
    
              ● 변수 혹은 상수에 접근할 수 있는 범위
              ● 모듈/함수 내 코드에서 동일한 변수 사용시 간섭을 줄이는 용도로 사용          -> 코드간에 구역을 나눈다. 
              ● Scope는 Global Scope와 Local Scope의 타입으로 구분
                  
                  ◽ Global Scope: 전역에 선언되어 어디에서도 접근 가능
                  ◽ Local Scope(block, function level scope): 특정 지역에 선언되어, 해당 지역 내에서만 접근 가능
                    
                    🔻 예제
                    
                    let x = 1;
                    let y = 2;
                    
                    console.log(x);     // 1
                    console.log(y);     // 2
                    
                    {                           ⭐ 중괄호 안에 있는것이, 하나의 영역이다.
                      // local scope
                      let x = 3;
                      let y = 4;
                      console.log(x);        // 3
                      console.log(y);        // 4
                    }
                    
                    function scope() {
                       let x = 5;
                       let y = 6;
                       console.log(x);      // 5
                       console.log(y);      // 6
                    }
                    
                    console.log(x);         // 1
                    console.log(y);         // 2
                    
                    ⭐ 전역 변수에 있는 변수는 누구나 접근 가능하다. 
                    
                         Ex)
                             let z = 3;
                             
                             {
                               console.log(z);     ⭐ z를 선언하지 않고, 전역 변수에 있는 z를 접근했을때, 접근이 가능하다.      // z = 3;
                             }                        다만 local scope에서, 전역 변수에 있는 변수와 동일한 식별자를 통해서 새로 변수를 선언해주면
                                                      오버랩되서 지워진다. 
                      
                      
                      🔻 예제코드 - 1
                      
                            // global scope
                            let A = 1;
                            let B = 2;

                            {
                               // local scope
                               let C = 3;
                               let D = 4;

                               console.log(A);      // 1
                               console.log(C);      // 3        
                            }                           ⭐ 이 local scope를 나가는 순간, garbage collector에 의해서 더 이상 참조하는것이 없어서
                                                            이 변수는 초기화 된다. 

                            console.log(C);         // ReferenceError: C is not defined
                                                     -> global scope에는 C가 없기 때문에, 접근할 수 없는 not defined가 발생한다. 
                       
                       🔻 예제코드 - 2
                            
                            // global scope
                            let A = 1;
                            
                            {
                               // local scope
                               let C = 3;
                               let D = 4;
                              
                               console.log(C);       // 3
                              
                               {                        ⭐ local scope내에 또 다른 local scope가 있는 경우.
                                 // local scope             -> 각각의 local scope에 대해서 오버라이딩 돼서 값을 참조한다. 
                                 let C = 5;
                                 let D = 6;
                                
                                 console.log(C);      // 5
                               }
                            }
                       
                        
                        🔻 예제코드 - 3
                        
                            * Local Scope내에서의 block level scope와 function level scope
                        
                            let index = 1000;
                            
                            function local_func() {         ⭐ function level scope  (-> function 내부에서 모두 접근 가능)
                               let index = 100;
                               
                               for (let index = 0; index < 10; index++) {       ⭐ block level scope (-> for문 안에 있는 블록에서만 유효)
                                  console.log(index);         // output: 0 ~ 9
                               }
                               
                               console.log(index);          // output: 100
                             }
                             
                             local_func();
                             console.log(index);        // output: 10000
                             
                             
    1️⃣5️⃣ 조건문      ⭐⭐ 중요!
    
    
          ● 알고리즘에서 논리적 비교를 할 때 사용되는 조건식
          ● if, if else, else 키워드를 통해 구성되며, 조건식에 맞을 경우 중괄호 {} 내에 있는 명령문을 수행
          ● 단, 실행 문장이 단일 문장인 경우에는 {} 생략 가능
            
            🔻 if-else 예제
            
                let apple_price = 9;
                
                if (apple_price >= 10) {
                    // 10 ~
                    console.log("very expensive :(");
                } else if (apple_price < 5) {
                    // 5 ~ 
                    console.log("very cheap :)");
                } else {
                    // 5 ~ 9
                    console.log("nice!");       // output: nice!
                }
                
                let age = 10;
                
                if (age < 10) // ~ 9
                    console.log("young!");
                else // 10 ~
                    console.log("old!");        // output: old!
    
                console.log("done!");
    
    
        🔎  3항 연산자          ⭐ 간단한 if-else일때는 한 줄로 쓸 수 있기 때문에, 많은 언어에서 3항 연산자를 사용한다. 
            
                ● 3항 연산자를 통해 if-else를 대체하여 사용 가능
                ● 3항 연산자: 변수 = (조건식) ? 참일 때 값 : 거짓일 때 값
                
                    🔻 예제
                    
                    let age = 20;
                    
                    // 조건문: if-else
                    if (age < 19) {
                       msg = "The user is not an adult.";
                    } else {
                       msg = "The user is an audlt.";
                    }
                    
                    console.log(msg);       // output: The user is an adult;
                    
                    // 조건문: 3항 연산자
                    msg_another = age < 19 ? The user is not an adult." : "The user is an adult.";
                    console.log(msg_another);           // output: The user is an adult.
    
    
    1️⃣6️⃣ 조건문 switch
    
           🔎 조건문 switch
           
                ● switch는 표현식을 평가하여 그 값이 일치하는 case문을 실행하는 조건문
                ● switch, case, break, default 키워드를 통해 구성되며, swtich의 조건에 맞는 case 구문을 수행
                ● 일반적으로 하나의 case만 수행되도록 case 끝을 break로 끝맺음
                
                      🔻 예제
                      
                        switch (ch) {           
                           case 1:
                             statements;
                             break;         ⭐ 원한다면, 여러개의 case가 실행되도록 break를 넣지 않는 경우도 있다. 
                           case 2;
                             statements;
                             break;
                           case 3;
                             statements;
                             break;
                        }                   ⭐ 위와 같이 default가 따로 없고, 해당하는 변수가 없으면 그대로 실행되지 않고 종료된다.
    
   
                🔻 switch 예제 - 1
                
                    let day_number = 1;
                    let day;        // 또는 let day = "";
                    
                    switch (day_number) {
                        case 0:
                          day = "Sunday"; break;        ⭐ break : 구문을 끝냄.
                        case 1:
                          day = "Monday"; break;
                        case 2:
                          day = "Tuesday"; break;
                        case 3:
                          day = "Wednesday"; break;
                        case 4:
                          day = "Thursday"; break;
                        case 5:
                          day = "Friday"; break;
                        case 6:
                          day = "Saturday"; break;
                        default:
                          day = "error"; break;
                      }
                      
                      console.log(day);                 // output: monday
                    
                    
                            🔻 break를 하지 않았을 경우,

                                let day_number = 4;
                                let day = "";

                                switch (day_number) {
                                  case 0:
                                    day = "Sunday"; break;
                                    .
                                    .
                                    .
                                  case 4:
                                    day = "Thurday";    ⭐ break가 없기 때문에, 
                                  case 5:               ⭐ case5로 넘어가고, Friday가 출력이 된다. 
                                    day = "Friday"; break;
                    
                    
                🔻 switch 예제 - 2
                    
                        let browser = "Chrome";
                        
                        switch (browser) {
                           case "Explorer":         ⭐ String뿐만 아니라 다른 논리적인 연산의 비교는 무조건 다 된다. 
                             msg = "ActiveX installation required.";
                             break;
                           case "Chrome":       ⭐ 구문도 없고, break도 없다.
                           case "Firefox":          -> case는 이미 비교를 하면 그 다음에 break를 만날 때 까지, 쭉 내려간다. 
                           case "Safari":
                           case "Opera":
                              msg = "Suppported browsers!";
                              break;
                           
                           default:
                              msg = "Unsupported browsers!";
                              break;
                         }
                         
                         console.log(msg);              // output: Supported browsers!
                         
                         ⭐⭐ 이런 케이스는, 특정 케이스 하나뿐만 아니라 여러개의 케이스에 대해서 모두 공통된 로직을 처리하는 내용이 있을 때,
                               이렇게 여러개의 케이스를 다중 중첩 시켜서 사용한다.
                         
                               -> 변경에 대한 최소화(문구가 한 개 변경되더라도 모두 다 변경 시켜야 하니까)와, 라인에 대한 최소화로 코드에 대한 효율성을 증가시킨다. 
     
     
    1️⃣7️⃣ 연습문제
    
         🔴 문제
         
             ● 조건문 switch를 이용하여 1~7사이의 숫자를 입력 받으면 요일을 출력해주는 코드를 작성하시오.
             ● 1(월요일) ~ 7(일요일)로 맵핑된다.
             
                  const day = 3;      ⭐ const로 했기 때문에, 코드 내에서 변하지 않는다. 
                  let weekend = "";
                    
                  switch (day) {
                      case 1: 
                        weekend = "월요일"; break;
                      case 2:
                        weekend = "화요일"; break;
                      case 3:
                        weekend = "수요일"; break;
                      case 4:
                        weekend = "목요일"; break;
                      case 5:
                        weekned = "금요일"; break;
                      case 6:
                        weekend = "토요일"; break;
                      case 7:
                        weekend = "일요일"; break;
                    }

                    console.log(weekend);
         
    
    1️⃣8️⃣ 반복문
    
         🔎 반복문 for
         
            ● 선언문(Init Expression), 조건문(Test Expression), 증감문(Update Expression) 형태로 이루어진 반복문
            ● 조건문이 fail이 되기 전까지 코드 블록을 계속적으로 반복 수행
            ● 선언문, 조건문, 증감문 자리에 공백 입력 가능
                
                🔻 예시
                
                   for (Init Expression; Test Expression; Update Expression) {
                      
                      // Statement Block
                   }      
                    
                    🔺 실행 순서
                    
                      1. Init expression : 변수에 대한 초기화가 이루어진다. let i = 0;
                      2. Test Expression : 앞에서 선언한 선언문에 대한 변수에 대한 컨트롤을 통해 조건문을 판단하게 된다. i < 5; 
                                           -> 논리적인 리턴값이 나오도록 부등호나 equal을 통해서 조건을 넣게 된다.
                      3. true가 나올 경우, for문안에 있는 코드가 수행된다.
                      4. 종료되면 block을 빠져 나와서 밖으로 가는게 아니라, Update Expression으로 이동한다. 
                      5. Update Expression : 선언문과 조건문에서 컨트롤해줬었던 변수에 대해서 업데이트를 해준다. i++, i-- 등. 
                      6. 업데이트 해준것이, 조건문에 부합되는지 확인하고 true이면 또 block안에 있는 코드를 실행 시킨다.
                      7. 그리고 다시 증감문으로 가서 업데이트가 된다.
                      8. 이 과정을 반복하다가, 조건문에서 더이상 true가 아니면 for문을 종료한다. 
                      
                      ⭐ 선언문(Init Expression)은 최초 1회만 실행이 되고, 그 이후에는 Test Expression과 Statement Block과 Update Expression을
                         반복하면서 조건판단을 한다. 
                      
                      
                    🔻 for 예제
            
                        // output: 0 1 2
                        for (let i = 0; i < 3; i++) {
                          console.log(i);
                        }
                        
                        // output: 
                        for (let i = 10; i < 3; i++) {
                          console.log(i);
                        }
                        
                        // output: 0 1
                        let num = 0;            ⭐ 변수 초기화를 여기에 함.
                        for (; num <2; ) {          ⭐ 선언문과 증감문이 없을 때.
                           console.log(num);
                           num++;               ⭐ 증감문이 없으면, 0에 대한 값이 변하지 않고 0인 상태로 실행되기 때문에 무한루프에 바지게 된다.       
                        }                           -> 무한루프에 빠지게 되면, 계속적으로 반복하기 때문에, 우리가 원하는 논리적인 코드를 작성할 수 없다.
                                                       그래서 이것을 멈추기 위해서 num++를 해준다. 
            
            
                    🔻 2중 for 예제        ⭐ 2중 / 3중 for문은 알고리즘에서도 많이 쓰인다. 
                        
                         for (let i = 0; i < 3; i++) {
                           for (let j = 0; j < 3; j++) {
                             console.log(`${i} + ${i + j}`);
                           }
                         }
                         
                         /* output
                         0 + 0 = 0
                         0 + 1 = 1
                         0 + 2 = 2
                         ...
                         2 + 1 = 3
                         2 + 2 = 4
                         */
                    
               🔎 반복문 for (확장)
               
                  ◻ for..in 반복문
                    ● 객체의 key, value 형태를 반복하여 수행하는데 최적화 된 유형
                    ● 첫번째부터 마지막까지, 객체의 키 개수만큼 반복
                        
                        Ex)
                           // Syntax
                              for (key in object) {
                                 // code block to be executed
                              }
                        
                        🔻 예시
                            
                            // Example
                            const person = { frame: "John", lname: "Bob", age: 25 };
                            
                            let text = "";
                            for (let x in person) {   ⭐ x에 key 값이 반환된다. 
                               text += person[x];
                            }
                            console.log(text);      // output: JohnBob25
                   
                   
                  ◻ for..of 반복문
                    ● Collection 객체 자체가 Symbol.iterator 속성(property)을 가지고 있어야 동작 가능한 유형
                    ● ES6에 새로 추가된 Collection 기반의 반복 구문
                        
                          Ex)
                             // Syntax
                              for (variable of iterable) {
                                 // code block to be executed
                              }
                        
                        🔻 예시
                            
                            // Example
                            let langauge = "JavaScript";    ⭐ String(문자형 자료형)에서 iterator 속성을 제공하기 때문에,
                                                               문자형에 대해서 for..of 반복문을 수행하게 되면 한 자, 한 자 나오게 된다. 
                            let text = "";
                            
                            for (let x of language) {
                               text += x;           ⭐ text에 x에 대한 값을 계속 누적시킨다. 
                               console.log(x);          // output: J \n a \n ... t
                            }
                            
                            console.log(text);          // output: JavaScript
            
    
    1️⃣9️⃣ 반복문 while
    
         🔎 반복문 while
         
            ● 조건문이 참일 때 코드 블록을 계속해서 반복 수행하는 반복문
            ● for문에 비해 선언문과 증감문 없이 loop를 수행하며, 무한 loop등 수행 시 많이 사용
            ● 조건문을 코드 블록보다 아래로 옮긴 do...while 반복문도 존재 (최소 한번 수행이 필요할 때 많이 사용)
    
                  🔻 예시
                  
                        🟠 While
                        
                        while (Test Expression) {       ⭐ Test Expression이 지속적으로 돌게 되면 무한 루프에 바지기 때문에
                                                             종료를 위한 변수 업데이트가 필요하다. 
                           // ... Statement Block ...
                                                            ⭐ 그래서 조건 판단에 대한 업데이트가 Statement Blcok안에서 이루어직 ㅔ된다.
                                                              조건이 false가 됬을때 구문 종료가 된다. 
                        }
                        
                        🟠 do...while
                        
                        do {
                           
                           // ... Statement Blcok ...
                           
                        } while (Test Expression);
    
    
                    ✅ while과 do...while의 차이점!
    
                        while은 처음 코드를 시작할 때, 조건문을 무조건 판단해서 만약에 false라면 수행을 안하고,
                        do...while은 일단 무조건 수행하고, 조건에 대한 판단은 마지막에 하게된다. return 값이 true이면, 다시 위로 올라가ㅓ서 수행을 한다.
                        
                        조건에 대한 판단을 앞에서 하면 while,
                        조건에 대한 판단을 뒤에서 하면 do...while이다.
                        
                        do...while은 뒤에서 하니까, 무조건 최초1회는 수행이 된다는 특성이 있어서,
                        어떤 코드가 무조건 한 번 수행이 되어야 할 때 많이 쓴다. 
                        
                        일반적으로는,
                        while이 do...while보다 더 많이 쓴다. 
                        
                            
                           🔻 while 예제
                           
                                let i = 0;
                                // output: 0 1 2        ⭐ 증감문이 없다면, 계속 0을 출력한다. 
                                while (i < 3) {
                                   console.log(i);
                                   i++;                 ⭐ while문은 변수에 대한 업데이트가 중요하다. 안그러면 무한 loop에 빠지게 된다. 
                                }
                               
                               🔻 do...while문
                               
                                // output: 0 1 2
                                i = 0;          ⭐ 현재 i가 2이기 때문에, 0으로 다시 초기화 해준다. 
                                do {
                                  console.log(i);
                                  i++;
                                } while (i < 3);
                                
                                
                                // output: 4
                                i = 4;;
                                do {
                                  console.log(i);
                                  i++;
                                } while (i < 3);
                     
    
    2️⃣0️⃣ 반복문 제어
    
           ◻ break
           
              ● 반복문 수행 시 코드 블록을 탈출할 때 사용되는 식별자
              ● 다중 반복문일 경우 가장 안쪽의 반복문을 종료
              ● Label을 통하여 다중 반복문을 한번에 종료 가능
                ※ Label : 반복문 앞에 콜론과 함께 쓰이는 식별자
           
           ◻ continue           ⭐ 특정 조건의 뒷 코드를 스킵하고 싶을 때 많이 사용한다. 
             
              ● 반복문 수행 시 코드 블록 실행을 해당 라인에서 중지하고,
                블록 코드를 종료 시킨 후 반복문 내 명시된 조건 판단.
    
             
             🔻 break, continue 예제
             
                // break
                   
                   let text = "";
                   
                   for (let i = 0; i < 10; i++) {
                     if ( i === 3) break;               ⭐ if / break가 없으면 0123456789이 출력 된다. 
                     text = text + i;                   ⭐ text += 1; 이렇게 해도 된다. 
                   }
                   
                   console.log(text);       // output: "012"
               
               // continue
                
                  text = "";
                  
                  for (let i = 0; i < 10; i++) {
                     if (i === 3) continue;         ⭐ i가 3일때 continue가 되서, i에 대한 값이 text에 업데이트가 안되고,
                     text = text + i;                   그 다음 for문이 이어서 수행된다. 
                  }
                  
                  console.log(text);         // output: "012456789"     ⭐ 3이 없음. 
             
             
             🔻 Label 예제
             
                  ● 프로그램 내 특정 영역을 지정하여 별도 이름을 붙이는 식별자   -> C언어 같은 경우, go-to 문법과 같이 쓰인다. 
                  ● break와 continue를 사용하는 반복문 안에서만 사용 가능하며, break나 continue 지시자 위에 있어야 함
                  
                        🔻 예제
                            
                            // output: 0 * 0 = 0 \n 1 * 0 = 0 \n 2 * 0 = 0
                            for (let i = 0; i < 3; i++) {
                              for (let j = 0; j < 3; j++) {
                                console.log(i + " * " + j + " = " + i * j);
                                break;       ⭐ 2중 for문일 때, break가 있으면 안쪽 for문에 대한 break만 수행이 된다. 
                              }                 -> 그래서 여기에서도 j가 0일때만 수행이 되고, break가 되기 대문에 j에 대한 1,2 case는 없다. 
                            }
                            
                            // output: 0 * 0 = 0    
                            end: for (let i = 0; i < 3; i++) {      ⭐ 2중 for문 자체를 종료시키고 싶을 때, 밖에 또 break를 해야할 때 좀 더 심플하게 할 수 있다. 
                               for (let j = 0; j < 3; j++) {
                                  console.log(i + " * " + j + " = " + i *j);
                                  break end;                ⭐ end의 전체에 대한 구문이 break 된다. 
                               }                                -> 그래서 i와 j모두 0까지만 출력이 된다. 
                            }   
           
                일반적으로는 label이 프로그램에 대한 가독성과 로직을 망가트리는 이유로 인해서,
                보통은 많이 사용하지 않는다. 현업에서도 사용하는걸 권장하는 분위기는 아니다. 
                
                일반적으로 로직을 구현할 때는, 특정 조건에 맞춰서 for문과 break를 통해서 잘 조합을 시켜서 로직을 구현하는게 좋다.  
           
           
    2️⃣1️⃣ 반복문 연습문제
            
          ⭐ 반복문은 보통 조건문과 같이 많이 사용한다. 
          
          🟠 문제 1
          
                ● 반복문 for를 이용하여 0부터 10까지의 정수 중 짝수의 합을 구한 뒤 출력해주는 코드를 작성하시오.
                    
                    const UNTIL_NUM = 10;
                    let sum = 0;

                    for (let i = 0; i <= UNTIL_NUM; i++) {      ⭐ UNTIL_NUM 상수를 사용해도 되고, 10을 사용해도 된다. 
                      if (i % 2 == 0) {                             
                          sum += i;                                 ⭐ i가 짝수일때만 더한다. 
                          console.log(i);                           ⭐ 짝수만 잘 더해지는지 확인.            
                      }

                    // 0 ~ 10: 10 8 6 4 2 -> 30
                    console.log(sum);   // output: 30
           
           
           🟠 문제 2
           
                ⭐ 구구단 코드는 대표적인 컴퓨터 language에서 구현할 때 많이 다루는 주제이다.
                
                 ● 반복문 for 2개를 이용하여 2~9단까지 출력해주는 코드를 작성하시오. 

                    for (let i = 2; i <= 9; i++) {
                      for (let j = 1; j <= 9; j++) {
                         console.log(`${i} x ${j} = ${i * j}`);                   // console.log(i + " x " + j + " = " + i * j);
                      }
                    }

                    /* output
                        2 x 1 = 2
                        ...
                        9 x 9 = 81
                    */
    
    
    2️⃣2️⃣ 함수
    
        ● 함수는 다수의 명령문을 코드 블록으로 감싸고, 하나의 실행 단위로 만든 코드의 집합
        ● 유사한 동작을 하는 코드를 하나로 묶어(->모듈화), 범용성을 확대시킨 블록 코드
        ● 함수는 정의 부분과 호출 부분으로 구성
        ● 함수는 가급적 한가지 일만 하며, 매개 변수는 최대 3개 이내로 작성을 권장
        
        ⭐ 함수는 한가지 일만 한다!
        
                🟥 함수 정의

                    1. 함수 선언식(Function Declarations)

                    2. 함수 표현식(Function Expressions)

                    3. 화살표 함수 (Arrow Function)
             
                🟥 함수 호출
                
                  ● 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않음
                  ● ES6에서 도입된 기본값을 통해 undefined 변수가 들어올 경우 값 초기화 지정 가능
                  
                    ⭐ 다른 언어에서는 매개변수와 인수의 개수가 일치하지 않으면, 컴파일 에러를 발생시키지만
                       자바스크립트는 개수가 일치하지 않아도 상관 없다. 
                  
                  ⭐ 함수 이름을 정할 때는, 함수 이름만 봐도 어떤 일을 하는지 유추할 수 있게 이름을 정해주는것이 좋다. 
        
        
                🔻 default value 예시
        
                    function print_add(x, y) {
                       console.log(x + y);
                    }
                    
                    print.add();        // NaN      ⭐ 아무것도 안넣었기 때문에, x와 y가 undefined라는 자료형이 들어가게 되서 undefined + undefined = NaN
                    print.add(10);      // NaN      ⭐ x는 10이지만, y는 아직 undefined이기 때문에 NaN가 된다. 
                    print.add(10,20);   // 30
                    print.add(10,20,3);         // 30           ⭐ x, y 이외의 또하나의 매개변수가 있다면, 넘어는 오지만 핸들링을 하지 않기 때문에 무시된다. 
                  
                  
                🔻 기본값 설정이 가능하다.
                    
                    function print_add(x, y = 10) {     ⭐ 기본값 설정. 
                       console.log(x + y);
                    }
                    
                    print.add(10);      // 20      ⭐ y가 undefined일 때 기본값이 설정이 되서, 10 + 10 = 20
                    
                    ⭐⭐ 기본값은 undefined일때만 수행이 되서, 실제 y를 넣어주면 넣어준 값이 더 우선시 된다.
                          -> 없을때만, 기본값으로 설정.
                          
                          Ex)
                             print.add(10, 20);         // 30
                    
                    
                  🔻 dynamic parameter 예시  
                    
                        : 매개변수에 아무것도 없어도, 실제 넘어오는 매개변수 값을 핸들링 할 수 있다. 
                          -> 내부에 arguments라는 변수가, 넘어오는 변수들을 자동으로 처리. 
                          
                          function print_min() {
                             console.log(argumnets)   // output: [Arguments] {'0': 10, '1': 20, '2': 30} 
                          }                             ⭐ -> 넣어준 인덱스에 맞춰서 값이 넘어온다.                           
                          print_min(10, 20, 30);
                          
                          
                          🔻 연산처리도 할 수 있따.
                            
                             function print_min() {
                                console.log(argumnets[0] - arguments[1]);       // output: -10 
                             }
                             
                             print.min(10, 20, 30);
                    
                        ⭐⭐ 일반적으로 함수는 이렇게 dynamic parameter로 사용하지 않고,
                              매개 변수로 데이터를 명시 해주는것이 일반적이다.
                              -> default 방법을 사용하는것이 좋다. 

                    
                🟥 함수 반환
                
                       위에서 했던 함수는, 반환이 없는 함수를 수행했다. -> void 함수 
                       
                       🟠 함수 반환 : 바로 출력하지말고, 결과값만 받고싶을 때 return value로 결과값을 전달해준다. 
                       
                            🔻 예시
                            
                               function add(x, y) {
                                  return x + y;
                               }
                               
                               add(10, 20);     ⭐ 이 상태로 실행하면 아무것도 나오지 않는다.
                                                    -> console.log를 찍지 않은것도 있지만,
                                                      실제 add를 호출한 다음에, 이 add 호출한것을 어디에 저장하지 않았다. (=> 받지 않음)
                              
                              그래서 아래와 같이 변경하면,
                              
                              function add(x, y) {
                                  return x + y;
                              }
                              
                              let result = add(10, 20);     ⭐ add에 대한 결과값을, result 변수에 저장.   -> 반환값을 넣어준다.
                              console.log(result);      // output: 30                    
                            
                            
                            ⭐⭐ return이 또 중요한 이유는, 결과에 대한 처리도 있지만 반복문에서 배웠던 break 역할도 한다.
                            
                                function add(x, y) {
                                    return x + y;       // break        -> ⭐ return 뒤에 코드는 수행이 안되고, 여기서 함수에 대한 break가 이루어진다. 
                                    console.log("hello!");                  ⭐ VS Code에서 보면, 이 부분이 흐릿하게 보이고 '접근할 수 없는 코드가 있습니다.'라고 나온다. 
                                }                                               -> 왜냐하면, 이 함수 내에서 이 부분으로 절대 올 수 없다. 이 전에 처리가 되기 때문에. 
                                
                                let result = add(10, 20);
                                console.log(result);    // output: 30
                                
                                🔻 위에 "hello!"를 나오게 하려면,
                                   순서를 위로 올려준다.
                                   
                                 function add(x, y) {
                                    console.log("hello!"); 
                                    return x + y;       
                                 }                                              
                                
                                 let result = add(10, 20);
                                 console.log(result);   
                                 
                                    🟠 출력결과 -> hello!
                                                   30
                                                   
                                                   
                    함수에 대한 break 역할도 return이 해줄 수 있다.
                    어떠한 결과값도 반환하지 않고 그냥 return을 하게되면, break처럼 쓸 수 있다.
                                   
                                 function add(x, y) {
                                    return;
                                    console.log("hello!");       
                                 }                                              
                                
                                 let result = add(10, 20);
                                 console.log(result);   
                                
                                    🟠 출력결과 -> undefined        ⭐ 어떠한 값도 return을 해주지 않았기 때문에. 
                            
                            ⭐ 값에 대한 반환(return) 뿐만 아니라, 함수에 대한 종료 역할도 같이 갖고 있다.
                                반복문과 마찬가지로 함수에서도 조건문과 같이 연동이 되서 사용한다.
                                
                                function checkAge(age) {
                                   if (age >= 18) return true;      ⭐ 조건문은 반복문에 이어서, 함수와도 같이 연동되서 많이 쓰인다.  
                                   else return false;
                                }
                                
                                console.log(checkAge(14));      // output: false  
                                checkAge(20);                   // output: true
                                                                  ⭐ checkAge를 변수로 바로 받아서 출력을 해도 된다.
                                                                     return 값을 직접적으로 바로 direct로 출력해도 되니까, 동일한 결과값이 나온다. 
         
         2️⃣3️⃣ 재귀 함수
         
            ● 함수 스스로 자신을 참조해 호출하면서 동일한 코드가 계속적으로 수행되는 함수 호출 방법
            ● 재귀 함수는 특정 조건이 됐을 때 자신을 그만 호출되도록 제한하는 exit code가 필요
          
           🟡 실제 컴퓨터는 재귀 함수를 몇번 호출되는지 stack이라는 영역을 통해서 기록하고 있다. 
             stack에 점진적으로 내부 호출했던 함수들이 쌓이면, 이 함수가 어떤 exit 코드에 의해서 종료되고
             그 이후 코드를 수행시킬 때, 어디로 가야되는지를 다 이 stack을 통해서 관리하게 된다. 
             -> 함수 내부적으로는 이렇게 동작.
             
             🔻 예시
             
                function recurse() {
                  // function code
                  recurse();
                }
                
                recurse();
        
        
         2️⃣4️⃣ 콜백 함수 
         
            ● 콜백 함수(Callback Function)란 다른 함수의 매개변수로 전달되어 수행되어지는 함수
            ● 고차 함수(Higher-order Function)란 매개변수를 통해 함수를 받아 호출하는 함수
            
                 🔻 예시
                 
                    function callback_func() {
                       console.log("I'm callback function");
                    }
                    
                    function higher_order_func(callback) {
                       console.log("I'm higher-order function");
                       callback();
                    }
              
                    higher_ordedr_func(callback_func);
                
         
         2️⃣5️⃣ 연습 문제 
         
             🟠 문제
             
                ● 두 정수를 입력 받아 가장 큰 값을 출력해주는 함수를 작성하시오.
                
                // case 1
                function MAX(x, y) {
                   if (x > y) {
                     return x;
                   } else {
                     return y;
                   }
                }
                
                // case 2 
                function MAX(x, y) {
                   return x > y ? x : y;
                }
   
                console.log(MAX(0, 3));         // output: 3
                console.log(MAX(-1, 5));       // output: 5
                consoel.log(MAX(100, 7));      // output: 100
    
    
         2️⃣6️⃣ method
         
            🔎 method
                
                ● 객체에 저장된 값이 함수인 경우, 이를 메서드(method)라고 부른다.
                
                    🔻 예시
                    
                       let user = {
                          name: "john",
                          age: 27,
                          hello_func() {
                             console.log("hello");
                          }
                       };
            
             🔎 this
             
                  ● 메서드에서 객체 내부의 속성(property) 값을 접근할 수 있는 지시자
                  
                        🔻 예시
                        
                           let obj = {
                              name: "john",
                              age: 27,
                              hello_func() {
                                 console.log(
                                     "hello " + this.name);
                              },
                            };
         
         
         2️⃣7️⃣ Number
            
            🔎 Number
                
               ● 자바스크립트에서 일반적인 숫자는 64비트 형식의 IEEE-754 표준 기반 형태로 저장되는 자료형
               ● 10진수 외에도 16진수, 2진수, 8진수 다양한 진수 사용
                  ◽ 16진수(hEXADECIMAL) 표기 : 0xFF
                  ◽ 8진수(Octal) 표기 : 0o71
                  ◽ 2진수(Binary) 표기 : 0b1101
               ● 대표 상수 값
                  ◽ [MAX | MIN]_VALUE, [MAX|MIN]_SAFE_INTEGER, [POSITIVE|NAGATIVE}_INFINITY, NaN
               ● 대표 메서드
                  ◽ 문자열로 변환 : Number.toString()
                  ◽ 특정 자리수까지 제한하여 숫자 표현: Number.toFixed(), Number.toPrecision()
                  ◽ 타입 확인 : Number.isNaN(), Number.isFinite()
           
           
         2️⃣8️⃣ String
         
             🔎 String
             
                ● 텍스트 길이에 상관없이 문자열 형태로 저장되는 자료형
                ● 자바스크립트에서는 글자 하나만 저장할 수 있는 char 자료형이 없음 
                ● 자바스크립트에서 문자열은 페이지 인코딩 방식과 상관없이 항상 UTF-16 형식을 따름
                ● 대표 속성(property)과 메서드(method)
                    
                    ◽ 문자열 길이: String.length
                    ◽ 문자열 접근: String.charAt(index), Stirng.charCodeAt(index)
                    ◽ 문자열 검색: String.indexOf(), String.lastindexOf(), String.includes(), String.startsWith() 등
                    ◽ 문자열 변환: String.toUpperCase(), String.toLowerCase()
                    ◽ 문자열 치환: String.replace()
                    ◽ 문자열 추출: String.slice(), String.substring(), String.substr()
                    ◽ 문자열 분할: String.split()
             
             
         2️⃣9️⃣ 문자열 치환
            
            🔎 문자열 치환
            
                ● 처음 만나는 요소 문자열 치환(치환된 문자열 반환): String.replace(origin_str, change_stR)
                ● 정규 표현식 활용 문자열 치환: 치환 문자열에 정규 표현식 기입-> / 치환문자열/g(전체)i(대소문자 구분 X)
                    
            🔎 문자열 추출
                
                ● 위치 기반 문자열 추출: String.slice(start,end), String.substring(start,end)
                ● 길이 기반 문자열 추출: String.substr(start,length)
                
            🔎 문자열 분할
                
                ● 배열로 문자열 분할: String.split(Separator,limit)
                    
         
         3️⃣0️⃣ Array
         
            🔎 배열               ⭐⭐⭐ 가장 중요한 객체 중 하나이다!!!
         
                ● 여러 개체(Entity)값을 순차적으로 나열한 자료 구조 (알고리즘 내 사용 빈도가 많다!)
                ● 배열 내 값을 요소(elemnt)라고 하며, 배열 요소는 index로 접근
                ● 대표 속성(property)과 메서드(method)
                
                    ◽ 배열 크기 및 배열 여부 확인: Array.length, Array.isArray()
                    ◽ 배열 추가/삭제: Array.push(), Array.pop(), Array.shift(), Array.unshift(), Array.splice(), Array.slice() 등
                    ◽ 배열 탐색: Array.indexOf(), Array.lastIndexOf(), Array.includes()
                    ◽ 배열 변형(callback 미사용): Array.sort(), Array.reverse(), Array.join()
                       
            🔎 배열 선언/접근/속성
            
               ● 선언: "new Array()" 혹은 "[]"를 통해 선언하며, 사이즈 혹은 값을 입력하여 초기화도 가능
               ● 접근 방법: "Array[index]"를 통해 index를 통하여 0(1) 접근
               ● 배열 속성: "Array.length"를 통해 배열 요소의 개수 확인 가능
                     
            🔴 배열의 실체  
                
              ● 자바스크립트에서 배열은 다른 언어에서 말하는 일반적인 배열이 아닌 Hash 기반의 객체
              ● 메모리가 연속적인 밀집 배열(dense array)가 아닌 비 연속적인 희소 배열(sparse array)              
              
            🔎 배열 타입 확인 및 요소 삭제
              
               ◻ 배열 타입 확인
                
                    🔻 배열 타입 확인 방법

                        Array.isArray(value)
               
               ◻ 배열 요소 삭제
               
                    🔻 배열 요소 삭제

                         delete array[index]          ⭐ 삭제해도 배열 사이즈가 그대로인 문제점이 있다. 
                                                         -> 그래서 배열에서 데이터를 삭제할 때는 delete를 사용하지 않는다. 
                                                            lenght에 대한 업데이트가 이루어지지 않고, 빈 공간이 그대로 남아있기 때문에. 

