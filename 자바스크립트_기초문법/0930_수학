
📂 기본 수학 이론

    🐥 오늘의 목표 : 기본 개념들에 대해서 이해하고, 여러가지 방법들을 어떻게 접근할 수 있는지 파악하기!
    

        1️⃣ Overview

             알고리즘 복잡도 / 경우의 수(순열과 조합) / 점화식

                  🟡 알고리즘 복잡도

                     ● 입력 크기의 값에 대해 단위 연산을 몇 번 수행하는지 계산하여, 알고리즘의 수행시간을 평가하는 방법
                     ● 3가지 점근적 표현법

                      ◽ 빅오 : 최악의 상황을 고려하여 성능 측정 결과 표현   ⭐ 대부분 빅오를 사용하여, 알고리즘의 성능 평가를 측정한다. 
                      ◽ 세타 : 평균적인 경우에서의 성능 측정 결과표현
                      ◽ 오메가 : 최선의 상황일 때의 성능 측정 결과 표현

                  🟡 경우의 수

                    ● 어떤 사건 혹은 일이 일어날 수 있는 경우의 가짓수를 수로 표현
                    ● 일상 생활에서의 경우의 수

                        ◽ 주사위: 던지는 결과, 1~6 사이의 숫자이므로 경우의 수는 6
                        ◽ 윷: 던지는 결과, 도, 개, 걸, 윷, 모 이므로 경우의 수는 5
                        ◽ 가위바위보: 게임 결과, 가위, 바위, 보 중에 하나를 낼 수 있으므로 경우의 수는 3
                        ◽ 동전: 던지는 결과, 앞면 혹은 뒷면이므로 경우의 수는 2

                   ● 완전 탐색으로 경우의 수를 푸는 알고리즘

                       ◽ 순열: 서로 다른 n개의 원소 중에서 r를 중복 없이 골라 순서에 상관 있게 나열하는 경우의 수
                       ◽ 조합: 서로 다른 n개의 원소 중에서 r를 중복 없이 골라 순서에 상관 없이 나열하는 경우의 수
                       ◽ 중복 순열 : 서로 다른 n개의 원소 중에서 r개를 중복 있게 골라 순서에 상관 없이 나열하는 경우의 수

                  🟡 점화식

                   ● 점화식(재귀식)이란, 수열에서 이웃하는 두개의 항 사이에 성립하는 관계를 나타낸 관계식
                   ● 대표적인 점화식

                      ◽ 등차 수열: F(n)=F(n-1)+a      *a: 고정된 상수
                      ◽ 등비 수열: F(n)=F(n-1)*a
                      ◽ 팩토리얼: F(n)=F(n-1)*n      
                      ◽ 피보나치 수열: F(n)=F(n-1)+F(n-2)

                                         ⭐ 대부분 프로그래밍에서는, 팩토리얼과 피보나치 수열을 많이 쓴다. 

                                     
                                     
        2️⃣ 알고리즘 복잡도
    
               🔻 알고리즘 성능 평가 지표 (5가지)
          
                      정확성 / 작업량 / 메모리 사용량 / 최적성 / 효율성 (시간 복잡도, 공간 복잡도)

                          ⭐⭐ 코딩테스트할때 제일 중요시 여겨할것이, '메모리 사용량'과 효율성 내에서의 '시간 복잡도'이다.
                                웬만한 문제에서는 메모리 사용량을 넉넉하게 주기 때문에, 시간복잡도 부분에서만 신경을 써서 문제를 풀면 된다.


              🔎 시간 복잡도

                 ● 입력 크기의 값에 대해 단위 연산을 몇 번 수행하는지 계산하여, 알고리즘의 수행시간을 평가하는 방법
                 ● 3가지 점근적 표현법

                    🟢 빅오 : 최악의 상황을 고려하여 성능 측정 결과 표현   ⭐ 알고리즘에서 대부분의 표현을 '빅오'를 사용한다. 
                    🟢 세타 : 평균적인 경우에서의 성능 측정 결과 표현
                    🟢 오메가 : 최선의 상황일 때의 성능 측정 결과 표현


                  *️⃣ Big-O Complexity Chart

                       ⭐ O(1)과 O(logn)이 아무리 요소들(Elements)이 증가하더라도, 빠른 퍼포먼스를 낸다.

                       그 다음 빠른 순서는,
                       O(n) -> O(n log n)이다.

                       그 다음으로 사용을 '지양'하는것은,
                       O(n^2), O(2^n), O(n!)이 있다.    * O(n^2): n제곱, O(2^n) : 2의 n승, O(n!) : 팩토리얼


                      💡 현재는 문제를 푸는것에 focusing을 둔다면, 익숙해지면 최적화하여 '시간 단축'을 병행하여 연습하는게 좋다.


                       🔻 빅오 표기법 예제 - 1

                          function big_o(n) {
                             let sum = 0;             // 1회

                             sum = n * 2;            // 1회

                             return sum;            // 1회
                         }
                                                  // -> 총 3회의 line code

                                                  3-> O(1)
                                                  : 3과 같은 상수를 가질 때는, 아무리 커지더라도 상수니까
                                                  이것을 O(1)을 표기한다. 
                                                  이런, 반복문이 없을때는 단순히 일련의 코드들만 수행할때는
                                                  O(1) 표기라고 보면 된다.


                       🔻 빅오 표기법  예제 -2      (⭐for문)

                           function big_o(arr, n) {
                               let sum = 0;                     // 1회

                               for (let i = 0; i < n; i++) {
                                  sum _= arr[i];                // n회
                               }

                               return sum;                    // 1회
                           }
                                                            n + 2 -> O(N)
                                                          = O(n+2)-> O(N)       * n+2는 n회+총2회이기 때문에. 
                                                          O(N)표기를 씌웠을때, 뒤쪽 상수를 날리고 가장 높은 차수만 남기는것이기 때문에, N상태로 있게 되고
                                                          O(N)표기를 하게 된다.    => for문 하나니까 O(N)   ⭐O(N)도 빠른 축에 속한다.

                               ⭐ 빅오 표기법은 for문이 몇개로 중첩되어 있는지 보면 된다. 
                                  for문이 많으면 많을수록, for문 하나당 n으로 보면된다.   -> for문이 2개면 n제곱.                 


                        🔻 빅오 표기법 예제 -3    (⭐for문이 2개일 때)

                            function big_o(arr, n) {                  // 1회
                               let sum = 0;

                               for (let i = 0; i < n; i++) {
                                  for (let j = 0; j < n; j++) {
                                     sum += arr[i][j];                // n * n =n의 제곱
                                  }
                                }

                                return sum;                          // 1회
                             }
                                                                    // n의 제곱 + 2 -> O(N의 제곱)
                                                                   // 만약에 n제곱+2가 아니라,
                                                                    n제곱 + n + 2가 되더라도 동일하게 O(N제곱)으로 표현된다. 
                                                                    왜냐하면, O(N제곱+n+2)로 표기했을 때,
                                                                    가장 높은 차수만 남기고 나머지는 다 제거하기 때문에
                                                                    O(N제곱)으로 표기된다. 

                                    ⭐⭐ N제곱이면 많이 느린것이다.
                                          N이 커지면 커질수록 정말 시간이 오래걸리는 코드로 보면 된다. 



                         🔻 빅오 표기법 예제 - 4

                              function big_o(n) {                       // 1회
                                 let sum = 0;

                                 for (let i = 0; i < n; i *= 2) {      // n/2회
                                     sum += 2;
                                 }

                                 return sum;                           // 1회
                              }
                                                                      n/2+2->O(log N)
                                                                      : 나누는 대상이 있을 때는, log N으로 표기한다.

                                                                      ⭐ 병합정렬이나 분할정복 할 때, log N이 많이 나오게 된다. 
                                                                         log N이 많으면 많을수록, 특정 이상 안올라가기 때문에,
                                                                         N보다 더 빠른 알고리즘을 갖고 있다. 

                               ⭐ 보통 log N케이스들이, 나중에 배울 merge sort나 분할정보 이런 문제에서 많이 나온다. 
                           
                           
                    *️⃣ Data Structure Opreations
                          
                          -> 구조를 참고해서, 실제 어떤 상황에서 어떤 Data Structure를 써야할지 파악 할 수 있다. 
                         
                         ⭐ Hash Table이 Search, Insertion, Deletion에서 O(1)이기 때문에,
                            실제 현업에서도 많이 사용된다.
                            
                            이 외에는, Array, Stack, Queue, Singly-Linked List, Doubly-Linked List도
                            커봐야 O(n)만큼이기 때문에, 이 자료형들도 많이 사용된다. 
                         
                    *️⃣ Array Sorting Algorithms
                    
                          -> 정렬을 하는 방법에도 수많은 방법들이 있다.
                             이 수많은 방법들 별로 각각 정렬하는 시간이 다르다.
                             (Time Complexity(시간 복잡도)와 Space Complexity(공간 복잡도)가 각각 다르게 나타남.)
                         
                  ⭐⭐⭐ 빅오 표기법에서,
                          for문을 중첩해서 많이 쓰게 되면, n이 증가하면 증가할수록 속도가 커지기 때문에
                          이런것들은 되도록 '지양'해야 한다는것 기억하기!
                  
                    
        3️⃣ 경우의 수
      
              : 어떤 사건 혹은 일이 일어날 수 잇는 경우의 가짓수를 수로 표현하는것.

              🔻 완전탐색으로 경우의 수를 푸는 알고리즘

                  순열 : 서로 다른 n개의 원소 중에서 r개를 중복 없이 골라서 '순서에 상관 있게' 나열하는 경우의 수(nPr)

                        * nPr : 서로 다른 원소 n개 중에서 순열 P를 써서 r개만큼 뽑으라는 뜻.  

                  조합 : 서로 다른 n개의 원소 중에서 r개를 중복 없이 골라서 '순서에 상관 없이' 나열하는 경우의 수(nCr)

                        * nCr : 서로 다른 n개의 원소 중에서 r개를 조합(Combination)으로 뽑는다는 뜻. 

                  중복 순열 : 서로 다른 n개의 원소 중에서 r개를 중복 있게 골라서 '순서에 상관 있게' 나열하는 경우의 수 (nH)
                    
       
        4️⃣ 순열 (Permutaion)
       
                ● '순서에 상관 있게' 나열하는 경우의 수 (nPr)    nPr = (n-1)!분의 n!
                ● 3개의 알파벳으로 단어를 만드는 경우의 수

                      A / B / C        -> 공식을 대입해보면,
                                          n개중에서 r개 선택이니까 3p3 : 3개 중에서 3개 선택. 

                                          (n-r)!은 0!  -> 1
                                          n!은 3!(3팩토리얼이니까)  -> 3 x 2 x 1

                                          그래서 6이 나오게 된다. (=> 6가지)


                ⭐ 일반적으로 순열을 쓸 때는, for loop보다는 재귀 함수를 많이 쓴다.

                   재귀 함수는, 아무리 배열 요소가 증가하더라도 한 개만 바꿔주면 되기 때문에, 손쉽게 확장할 수 있다. 
             
       
        5️⃣ 조합 (Combination)
       
               ● '순서에 상관 없이' 나열하는 경우의 수 (nCr)    nCr = (n-r)! r!분의 n!
               ● 4개의 숫자 카드에서 2개를 뽑는 경우의 수

                     1 / 2 / 3 / 4        -> 공식에 대입해보면,
                                             4개중에서 2개 선택이니까 4C2,
                                             2!2!분의 4!이니까,
                                             2x1x2x1분의 4x3x2x1
                                             = 4분의 24
                                             = 6      => 6가지가 나온다. 

