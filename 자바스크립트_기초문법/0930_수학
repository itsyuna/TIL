
📂 기본 수학 이론

    🐥 오늘의 목표 : 기본 개념들에 대해서 이해하고, 여러가지 방법들을 어떻게 접근할 수 있는지 파악하기!
    

        1️⃣ Overview

             알고리즘 복잡도 / 경우의 수(순열과 조합) / 점화식

                  🟡 알고리즘 복잡도

                     ● 입력 크기의 값에 대해 단위 연산을 몇 번 수행하는지 계산하여, 알고리즘의 수행시간을 평가하는 방법
                     ● 3가지 점근적 표현법

                      ◽ 빅오 : 최악의 상황을 고려하여 성능 측정 결과 표현   ⭐ 대부분 빅오를 사용하여, 알고리즘의 성능 평가를 측정한다. 
                      ◽ 세타 : 평균적인 경우에서의 성능 측정 결과표현
                      ◽ 오메가 : 최선의 상황일 때의 성능 측정 결과 표현

                  🟡 경우의 수

                    ● 어떤 사건 혹은 일이 일어날 수 있는 경우의 가짓수를 수로 표현
                    ● 일상 생활에서의 경우의 수

                        ◽ 주사위: 던지는 결과, 1~6 사이의 숫자이므로 경우의 수는 6
                        ◽ 윷: 던지는 결과, 도, 개, 걸, 윷, 모 이므로 경우의 수는 5
                        ◽ 가위바위보: 게임 결과, 가위, 바위, 보 중에 하나를 낼 수 있으므로 경우의 수는 3
                        ◽ 동전: 던지는 결과, 앞면 혹은 뒷면이므로 경우의 수는 2

                   ● 완전 탐색으로 경우의 수를 푸는 알고리즘

                       ◽ 순열: 서로 다른 n개의 원소 중에서 r를 중복 없이 골라 순서에 상관 있게 나열하는 경우의 수
                       ◽ 조합: 서로 다른 n개의 원소 중에서 r를 중복 없이 골라 순서에 상관 없이 나열하는 경우의 수
                       ◽ 중복 순열 : 서로 다른 n개의 원소 중에서 r개를 중복 있게 골라 순서에 상관 없이 나열하는 경우의 수

                  🟡 점화식

                   ● 점화식(재귀식)이란, 수열에서 이웃하는 두개의 항 사이에 성립하는 관계를 나타낸 관계식
                   ● 대표적인 점화식

                      ◽ 등차 수열: F(n)=F(n-1)+a      *a: 고정된 상수
                      ◽ 등비 수열: F(n)=F(n-1)*a
                      ◽ 팩토리얼: F(n)=F(n-1)*n      
                      ◽ 피보나치 수열: F(n)=F(n-1)+F(n-2)

                                         ⭐ 대부분 프로그래밍에서는, 팩토리얼과 피보나치 수열을 많이 쓴다. 

                                     
                                     
        2️⃣ 알고리즘 복잡도
    
               🔻 알고리즘 성능 평가 지표 (5가지)
          
                      정확성 / 작업량 / 메모리 사용량 / 최적성 / 효율성 (시간 복잡도, 공간 복잡도)

                          ⭐⭐ 코딩테스트할때 제일 중요시 여겨할것이, '메모리 사용량'과 효율성 내에서의 '시간 복잡도'이다.
                                웬만한 문제에서는 메모리 사용량을 넉넉하게 주기 때문에, 시간복잡도 부분에서만 신경을 써서 문제를 풀면 된다.


              🔎 시간 복잡도

                 ● 입력 크기의 값에 대해 단위 연산을 몇 번 수행하는지 계산하여, 알고리즘의 수행시간을 평가하는 방법
                 ● 3가지 점근적 표현법

                    🟢 빅오 : 최악의 상황을 고려하여 성능 측정 결과 표현   ⭐ 알고리즘에서 대부분의 표현을 '빅오'를 사용한다. 
                    🟢 세타 : 평균적인 경우에서의 성능 측정 결과 표현
                    🟢 오메가 : 최선의 상황일 때의 성능 측정 결과 표현


                  *️⃣ Big-O Complexity Chart

                       ⭐ O(1)과 O(logn)이 아무리 요소들(Elements)이 증가하더라도, 빠른 퍼포먼스를 낸다.

                       그 다음 빠른 순서는,
                       O(n) -> O(n log n)이다.

                       그 다음으로 사용을 '지양'하는것은,
                       O(n^2), O(2^n), O(n!)이 있다.    * O(n^2): n제곱, O(2^n) : 2의 n승, O(n!) : 팩토리얼


                      💡 현재는 문제를 푸는것에 focusing을 둔다면, 익숙해지면 최적화하여 '시간 단축'을 병행하여 연습하는게 좋다.


                       🔻 빅오 표기법 예제 - 1

                          function big_o(n) {
                             let sum = 0;             // 1회

                             sum = n * 2;            // 1회

                             return sum;            // 1회
                         }
                                                  // -> 총 3회의 line code

                                                  3-> O(1)
                                                  : 3과 같은 상수를 가질 때는, 아무리 커지더라도 상수니까
                                                  이것을 O(1)을 표기한다. 
                                                  이런, 반복문이 없을때는 단순히 일련의 코드들만 수행할때는
                                                  O(1) 표기라고 보면 된다.


                       🔻 빅오 표기법  예제 -2      (⭐for문)

                           function big_o(arr, n) {
                               let sum = 0;                     // 1회

                               for (let i = 0; i < n; i++) {
                                  sum _= arr[i];                // n회
                               }

                               return sum;                    // 1회
                           }
                                                            n + 2 -> O(N)
                                                          = O(n+2)-> O(N)       * n+2는 n회+총2회이기 때문에. 
                                                          O(N)표기를 씌웠을때, 뒤쪽 상수를 날리고 가장 높은 차수만 남기는것이기 때문에, N상태로 있게 되고
                                                          O(N)표기를 하게 된다.    => for문 하나니까 O(N)   ⭐O(N)도 빠른 축에 속한다.

                               ⭐ 빅오 표기법은 for문이 몇개로 중첩되어 있는지 보면 된다. 
                                  for문이 많으면 많을수록, for문 하나당 n으로 보면된다.   -> for문이 2개면 n제곱.                 


                        🔻 빅오 표기법 예제 -3    (⭐for문이 2개일 때)

                            function big_o(arr, n) {                  // 1회
                               let sum = 0;

                               for (let i = 0; i < n; i++) {
                                  for (let j = 0; j < n; j++) {
                                     sum += arr[i][j];                // n * n =n의 제곱
                                  }
                                }

                                return sum;                          // 1회
                             }
                                                                    // n의 제곱 + 2 -> O(N의 제곱)
                                                                   // 만약에 n제곱+2가 아니라,
                                                                    n제곱 + n + 2가 되더라도 동일하게 O(N제곱)으로 표현된다. 
                                                                    왜냐하면, O(N제곱+n+2)로 표기했을 때,
                                                                    가장 높은 차수만 남기고 나머지는 다 제거하기 때문에
                                                                    O(N제곱)으로 표기된다. 

                                    ⭐⭐ N제곱이면 많이 느린것이다.
                                          N이 커지면 커질수록 정말 시간이 오래걸리는 코드로 보면 된다. 



                         🔻 빅오 표기법 예제 - 4

                              function big_o(n) {                       // 1회
                                 let sum = 0;

                                 for (let i = 0; i < n; i *= 2) {      // n/2회
                                     sum += 2;
                                 }

                                 return sum;                           // 1회
                              }
                                                                      n/2+2->O(log N)
                                                                      : 나누는 대상이 있을 때는, log N으로 표기한다.

                                                                      ⭐ 병합정렬이나 분할정복 할 때, log N이 많이 나오게 된다. 
                                                                         log N이 많으면 많을수록, 특정 이상 안올라가기 때문에,
                                                                         N보다 더 빠른 알고리즘을 갖고 있다. 

                               ⭐ 보통 log N케이스들이, 나중에 배울 merge sort나 분할정보 이런 문제에서 많이 나온다. 
                           
                           
                    *️⃣ Data Structure Opreations
                          
                          -> 구조를 참고해서, 실제 어떤 상황에서 어떤 Data Structure를 써야할지 파악 할 수 있다. 
                         
                         ⭐ Hash Table이 Search, Insertion, Deletion에서 O(1)이기 때문에,
                            실제 현업에서도 많이 사용된다.
                            
                            이 외에는, Array, Stack, Queue, Singly-Linked List, Doubly-Linked List도
                            커봐야 O(n)만큼이기 때문에, 이 자료형들도 많이 사용된다. 
                         
                    *️⃣ Array Sorting Algorithms
                    
                          -> 정렬을 하는 방법에도 수많은 방법들이 있다.
                             이 수많은 방법들 별로 각각 정렬하는 시간이 다르다.
                             (Time Complexity(시간 복잡도)와 Space Complexity(공간 복잡도)가 각각 다르게 나타남.)
                         
                  ⭐⭐⭐ 빅오 표기법에서,
                          for문을 중첩해서 많이 쓰게 되면, n이 증가하면 증가할수록 속도가 커지기 때문에
                          이런것들은 되도록 '지양'해야 한다는것 기억하기!
                  
                    
        3️⃣ 경우의 수
      
              : 어떤 사건 혹은 일이 일어날 수 잇는 경우의 가짓수를 수로 표현하는것.

              🔻 완전탐색으로 경우의 수를 푸는 알고리즘

                  순열 : 서로 다른 n개의 원소 중에서 r개를 중복 없이 골라서 '순서에 상관 있게' 나열하는 경우의 수(nPr)

                        * nPr : 서로 다른 원소 n개 중에서 순열 P를 써서 r개만큼 뽑으라는 뜻.  

                  조합 : 서로 다른 n개의 원소 중에서 r개를 중복 없이 골라서 '순서에 상관 없이' 나열하는 경우의 수(nCr)

                        * nCr : 서로 다른 n개의 원소 중에서 r개를 조합(Combination)으로 뽑는다는 뜻. 

                  중복 순열 : 서로 다른 n개의 원소 중에서 r개를 중복 있게 골라서 '순서에 상관 있게' 나열하는 경우의 수 (nH)
                    
       
        4️⃣ 순열 (Permutaion)
       
                ● '순서에 상관 있게' 나열하는 경우의 수 (nPr)    nPr = (n-1)!분의 n!
                ● 3개의 알파벳으로 단어를 만드는 경우의 수

                      A / B / C        -> 공식을 대입해보면,
                                          n개중에서 r개 선택이니까 3p3 : 3개 중에서 3개 선택. 

                                          (n-r)!은 0!  -> 1
                                          n!은 3!(3팩토리얼이니까)  -> 3 x 2 x 1

                                          그래서 6이 나오게 된다. (=> 6가지)


                ⭐ 일반적으로 순열을 쓸 때는, for loop보다는 재귀 함수를 많이 쓴다.

                   재귀 함수는, 아무리 배열 요소가 증가하더라도 한 개만 바꿔주면 되기 때문에, 손쉽게 확장할 수 있다. 
             
       
        5️⃣ 조합 (Combination)
       
               ● '순서에 상관 없이' 나열하는 경우의 수 (nCr)    nCr = (n-r)! r!분의 n!
               ● 4개의 숫자 카드에서 2개를 뽑는 경우의 수

                     1 / 2 / 3 / 4        -> 공식에 대입해보면,
                                             4개중에서 2개 선택이니까 4C2,
                                             2!2!분의 4!이니까,
                                             2x1x2x1분의 4x3x2x1
                                             = 4분의 24
                                             = 6      => 6가지가 나온다. 
       
        6️⃣ 점화식 (=재귀식)
        
            ● 점화식(재귀식)이란 수열에서 이웃하는 두개의 항 사이에 성립하는 관계를 나타낸 관계식이다.
            ● 대표적인 점화식
            
                 등차 수열 / 등비 수열 / 팩토리얼 / 피보나치 수열 
                 
                 -> 보통 이런 사례들은, 귀납적 추론들을 통해서 이런 수식들을 이끌어내고,
                    이 수식들을 바탕으로 재귀나 다이나믹 프로그램들을 사용하는데 밑바탕이 되는 수식이 된다. 
                
                
                수식      1차               2차           결과
                f(1)                                      = 3
                f(2)    = f(1) + 2       = 3 + 2          = 5
                f(3)    = f(2) + 2       = 5 + 2          = 7
                f(4)    = f(3) + 2       = 7 + 2          = 9
                f(5)    = f(4) + 2       = 9 + 2          = 11
                f(n)           = f(n-1) + =2, f(1) = 3
                
                
                🔻 등차수열 예제 - 1              ⭐for문
                
                        let result;

                        function forloop(s, t, number) {      ⭐ s: start(초기함수), t: 간격(=등차값), number(개수. 얼마만큼 반복할건지)
                          let acc = 0;                        ⭐ acc를 통해서 각각의 요소별로 등차값을 판단한다. ex) 5번째 요소에 대한 값은 무엇인지 acc에 저장됨. 

                          for (let i = 1; i <= number; i++) {
                             if (i == 1)
                               acc += s;
                             else 
                               acc += t;

                             console.log(i, acC);
                          }

                          return acc;

                        }

                        result = forloop(3, 2, 5);
                        console.log(result);                // output: 1 3          첫번째 항일 때 3,
                                                                       2 5          두번째 항일 때 5... 이런식으로 나온다. 
                                                                       3 7
                                                                       4 9
                                                                       5 11
                                                                       11
                    
                    
                🔻 등차수열 예제 - 2              ⭐ 재귀
                    
                        let result;

                        function recursive(s, t, number) {
                            // 멈출 조건
                            if (number == 1) {              ⭐ 재귀에서 제일 중요한것은, 멈추는 타이밍!
                               return s;
                            }

                            // 반복할 코드
                            return recursive(s, t, number - 1) + t;
                        }

                        // number: 5 => 9 + 2        : recursive(s, t, 4) + 2
                        // number: 4 => 7 + 2        : recursive(s, t, 3) + 2
                        // number: 3 => 5 + 2        : recursive(s, t, 2) + 2
                        // number: 2 => 3 + 2        : recursive(s, t, 1) + 2
                        // number: 1 -> 3

                        result = recursive(3, 2, 5);
                        console.log(result);                // ouput: 11

                    
                🔻 등비수열 예제 - 1      ⭐ for문  
                
                                         ⭐⭐ 등차수열과 다른점은, 
                                               등차수열은 +연산으로 하나하나씩 추가가 됐지만,
                                               등비수열은 일정한 비율로 저장이 된다.
                                               상수만큼 이전항 대비 지속적으로 곱해진다.
                                               -> +대신 *으로 변경하면 등비수열이 된다. 
                
                        let result;
                        
                        function forloop(s, t, number) {
                           let acc = 1;
                           
                           for (let i = 1; i <= number; i++) {
                              if (i == 1)
                                acc *= s;
                              else 
                                acc *= t;
                                
                              console.log(i, acc);
                           }
                           
                           return acc;
                        }
                        
                        result = forloop(3, 2, 5);
                        console.log(result);                // output: 1 3
                                                                       2 6
                                                                       3 12
                                                                       4 24
                                                                       5 48
                                                                       48
        
        
                🔻 등비수열 예제 - 2                          ⭐ 재귀함수      -> 마찬가지로 +를 *로 바꾸면 등비수열이 된다. 
                
                       let result;
                       function recursive(s, t, number) {
                          if (number == 1) {
                             return s;
                          }
                          
                          return recursive(s, t, number - 1) * t;
                       }
                       
                       result = recursive(3, 2, 5);
                       console.log(result);             // output: 48
                        
                        
               🔻 팩토리얼 예제              ⭐ 팩토리얼도 많이 쓰이는 case이다. 
                                            ⭐ for문도 가능하지만, 좀 더 간단하게 재귀함수로!
               
                        let result;
                        
                        function recursive(number) {
                            if (number == 1) {
                               return number;
                            }
                            
                            return recursive(number -1) * number;
                        }
                        
                        result = recursive(5);      // 5! => 5 x 4 x 3 x 2 x 1
                        console.log(result);        // output: 120
               
               
               🔻 피보나치 수열 예제             : 피보나치 수열은, 이전값과 이전전 값을 더한값이 현재의 값이다.
                                                
                                                ⭐재귀 함수                                           
                        let result;
                        
                        function recursive(number) {
                            if (number == 1 || number == 0) {
                               return number;
                            }
                            
                            // f(n) = f(n - 1) + f(n - 2)
                            return recursive(number - 1) + recursive(number -2);
                        }
                        
                        result = recursive(5);
                        console.log(result);            // output: 5
                            
     
       #️⃣ 기본 문제 풀이(1) - 등차수열의 항 찾기
     
              🟠 문제 
              
              -> 입력된 값을 통해서 등차 수열의 몇 번째 항인지를 구하는 프로그램을 작성하시오.
                 입력은 초항 a, 인접한 차이 d, 찾는 항의 수 n이 주어지며, n 값에 해당하는 항 번호를 반환한다.
                 단, 만약 항 번호가 없을 시에는 -1를 반환한다.
                 예를 들어 a=1, d=2, n=7이 주어졌을 때,
                 f(1)=1, f(2)=3, f(3)=5, f(4)=7이 되므로, n=7에 해당하는 항인 4를 반환한다.
                
                 입력 값       출력값
                 
                 1 2 7           4
                 2 3 10         -1
                 3 5 23          5
                 
                 🔻 코드 구현
                                            ⭐ recursive를 사용하지 않고, for문을 통해서 구현해보기.
                    /* user code */
                    function answer(a, d, n) {
                       let index = -1;
                       
                       // 등차수열
                       let num;
                       for (let i = 1; ; i++) {     ⭐ 언제까지 증가할지 모르지만, break 조건이 있어야 하니까 일단 이부분은 
                                                       무한대로 while문처럼 빈 공란으로 줘서 항상 true도 계속 반복해서 돌게끔 한다.
                         num = a + d * (i - 1);        i++를 통해서, 내부적으로 if break를 통해서 for문으로 멈추도록 한다.
                                                        -> 이유는, 연산값이 업데이트 돼서 비교를 해야 하는데
                                                           i만 쓰는 for문 안에 쓰는것 보다, 바깥에서 break를 하는것이 좀 더 가시성이 좋아서 이렇게 작성해준다. 
                         // 찾지 못함
                         if (num > n) {
                            index = -1;
                            break;
                         }
                        
                         // 답 찾음
                         if (num == n) {
                             index = i;
                             break;
                         }
                        
                         // console.log(num);
                      }
                      
                      return index; 
                   }
                    
                    /* main code*/
                    let input = [
                       // TC: 1
                       [1, 2, 7]
                       
                       // TC: 2
                       [2, 3, 10]
                       
                       // TC: 3
                       [3, 5, 23]
                    ];
                    
                    for (let i = 0; i < input.length; i++) {
                       console.log(`#${i + 1} ${answer(input[i][0], input[i][1], input[i][2])}`);
                    }
            
            
            🔻 또 다른 솔루션      ⭐ if문 조건 하나라도 값을 구할 수 있다. 
                    
                   // 1, 3, 5, 7
                   // (7-1) -> 6 % 2 = 0
                   function answer(a, d, n) {
                       let index = -1;
                       
                       if ((n - a) % d == 0) {      ⭐ 나머지가 0이 나오면 등차수열로 이루어진 값이라고 판단. 
                          index;                    ⭐ -> 그리고나서, 몇번째 항인지 해당하는 index값을 반환해준다. 
                                                  ⭐⭐ index를 좀 더  빨리 찾으려면, index = (n - a) / d + 1;
                                                     -> +1을 해주는건, 초항값때문에 해줌. n-a의 나머지를 d로 나누면 몇번만큼 +가 됐는지
                                                        알 수 있으니까, 그 횟수 +1(초항값)을 하면 index 값이 나온다. 
                       } else index = -1;
                     
                      return index;
                   }
                    
                    /* main code*/
                    let input = [
                       // TC: 1
                       [1, 2, 7]
                       
                       // TC: 2
                       [2, 3, 10]
                       
                       // TC: 3
                       [3, 5, 23]
                    ];
                    
                    for (let i = 0; i < input.length; i++) {
                       console.log(`#${i + 1} ${answer(input[i][0], input[i][1], input[i][2])}`);
                    }
            
          ⭐ 푸는 방법은, 이거 외에도 여러가지 방법이 있겠지만,  
             실제 알고리즘 성능 평가 측면에서 봤을때는 앞에서 했던것보다, 
             연산속도가 지금 구현한게 훨씬 빠르기때문에 이런 알고리즘으로 작성하는것이 좋다 .  
                    
                    
       #️⃣ 기본 문제 풀이(2) - 잃어버린 카드 찾기
     
                🟠 문제
                
                -> 등차 수열을 이루는 4개의 숫자 카드를 받았는데, 한 카드를 잃어버렸다. 잊어버린 카드를 찾아주자.
                   입력은 자연수로 된 3개의 숫자 카드를 받고, 한 가지의 잃어버린 카드의 수를 반환한다.
                   단, 잃어버린 카드는 가운데 숫자 카드로 한정한다.
                   예를 들어 1, 7, 10을 입력 받았을 때
                   초항이 1이고, 두 수 의 차가 3인, 등차 수열 1, 4, 7, 10을 찾아 반환하도록 한다.
                   
                   입력 값        출력값
                   1 7 10          4
                   3 8 18          13
                   11 2 5          8
                   
                   
                   🔻 코드 구현
                   
                   /* user code */
                   function answer(a, b, c) {
                      let number = 0;
                      
                      // sort
                      num = [a, b, c]
                      num.sort((x,) => x - y);
                      
                      // 1. get d -> 등차값 찾기
                      let d = 0;
                      for (let i = 1; i < num.length; i++) {
                         d += num[i] - num[i -1];
                      }
                      d /= num.length;      ⭐ num.length로 나누는게 좋다. 길이가 증가되더라도 바로 대처할 수 있기 때문에, 좀 더 좋은 코드가 된다. 
                      
                      // 2. 빈 index 찾기
                      let index = num[2] - num[1] > num[1] - num[0] ? 2 : 1;  
                   
                      // 3. 이전 값 + d
                      num = num[0] + d * index;
                  
                      return number;
                   }
                   
                   // 1, 7, 10
                   // 6 + 3 = 9 / 3
                   
                   /* main colde */
                   let input = [
                     // TC: 1
                     [1, 7, 10],
                     
                     // TC: 2
                     [3, 8, 18],
                     
                     // TC: 3
                     [2, 5, 11],
                   ];
                   
                   for (let i = 0; i < input.length; i++) {
                      console.log(`#${i + 1} ${answer(input[i][0], input[i][1], input[i][2])}`);
                   }
        
     
